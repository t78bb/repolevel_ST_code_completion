[["```\nVAR\n\treceivedFrame : Can_baseframe; // Variable to store the received CAN frame\nEND_VAR\n\nCASE SWMC_ID OF\n\t1:\n\t\treceivedFrame := gCan.C1RxMsg.RXMsg[I]; // Retrieve data from CAN channel 1\n\t\tgCan.C1RxMsg.RxCounter := gCan.C1RxMsg.RxCounter + 1; // Increment the receive counter\n\t2:\n\t\treceivedFrame := gCan.C2RxMsg.RXMsg[I]; // Retrieve data from CAN channel 2\n\t\tgCan.C2RxMsg.RxCounter := gCan.C2RxMsg.RxCounter + 1; // Increment the receive counter\n\t3:\n\t\treceivedFrame := gCan.C3RxMsg.RXMsg[I]; // Retrieve data from CAN channel 3\n\t\tgCan.C3RxMsg.RxCounter := gCan.C3RxMsg.RxCounter + 1; // Increment the receive counter\n\t4:\n\t\treceivedFrame := gCan.C4RxMsg.RXMsg[I]; // Retrieve data from CAN channel 4\n\t\tgCan.C4RxMsg.RxCounter := gCan.C4RxMsg.RxCounter + 1; // Increment the receive counter\n\tELSE\n\t\treceivedFrame := Can_baseframe(); // Return an empty frame if SWMC_ID is invalid\nEND_CASE;\n\nRETURN receivedFrame; // Return the received CAN frame\n```"], ["```pascal\nVAR\n    result : BOOL;\nEND_VAR\n\nresult := FALSE;\n\n// Simulate sending data to the CAN bus\nIF (SWMC_ID > 0) AND (id > 0) THEN\n    // Here you would typically call a hardware-specific function to send the data\n    // For example: CAN_Write(SWMC_ID, id, data);\n    result := TRUE; // Assume the data was sent successfully\nEND_IF;\n\nRETURN result;\nEND_FUNCTION\n\n// Additional code to handle the CAN communication logic\nFUNCTION_BLOCK CAN_Controller\nVAR\n    sendCounter : UINT;\nEND_VAR\n\nMETHOD Initialize : BOOL\nVAR\n    success : BOOL;\nEND_VAR\n\nsuccess := FALSE;\n\n// Initialize the CAN controller\n// For example: CAN_Init();\n\nsendCounter := 0;\nsuccess := TRUE;\n\nRETURN success;\nEND_METHOD\n\nMETHOD SendData : BOOL\nVAR\n    success : BOOL;\n    sendData : ARRAY[1..8] OF BYTE;\n    swmcIdSwitch : UINT;\nEND_VAR\n\nsuccess := FALSE;\n\n// Example logic for sending data\nswmcIdSwitch := sendCounter MOD 2;\n\nCASE swmcIdSwitch OF\n    0:\n        sendData[1] := WORD_TO_BYTE(gController.sky[3].extendPercent);\n        sendData[2] := WORD_TO_BYTE(SHR(gController.sky[3].extendPercent, 8));\n        sendData[3] := WORD_TO_BYTE(gController.sky[3].retractPercent);\n        sendData[4] := WORD_TO_BYTE(SHR(gController.sky[3].retractPercent, 8));\n        sendData[5] := WORD_TO_BYTE(gController.sky[4].extendPercent);\n        sendData[6] := WORD_TO_BYTE(SHR(gController.sky[4].extendPercent, 8));\n        sendData[7] := WORD_TO_BYTE(gController.sky[4].retractPercent);\n        sendData[8] := WORD_TO_BYTE(SHR(gController.sky[4].retractPercent, 8));\n        success := CAN_Send_Data_SWMC(1, 16#500, sendData);\n    1:\n        sendData[1] := WORD_TO_BYTE(gController.sky[5].extendPercent);\n        sendData[2] := WORD_TO_BYTE(SHR(gController.sky[5].extendPercent, 8));\n        sendData[3] := WORD_TO_BYTE(gController.sky[5].retractPercent);\n        sendData[4] := WORD_TO_BYTE(SHR(gController.sky[5].retractPercent, 8));\n        sendData[5] := WORD_TO_BYTE(gController.sky[6].extendPercent);\n        sendData[6] := WORD_TO_BYTE(SHR(gController.sky[6].extendPercent, 8));\n        sendData[7] := WORD_TO_BYTE(gController.sky[6].retractPercent);\n        sendData[8] := WORD_TO_BYTE(SHR(gController.sky[6].retractPercent, 8));\n        success := CAN_Send_Data_SWMC(1, 16#501, sendData);\nEND_CASE;\n\nsendCounter := sendCounter + 1;\n\nRETURN success;\nEND_METHOD\n```"], ["```\nVAR\n\tdirect\t\t:TargetDirect;\t//\u65b9\u5411\nEND_VAR\n\nCASE direct OF\n\tTargetDirect.extend:\n\t\tCASE level OF\n\t\t\t1:\n\t\t\t\tgController.grd[idx].extendPercent := REAL_TO_WORD(percent * 65535 / 100);\n\t\t\t\tgController.grd[idx].retractPercent := 0;\n\t\t\t2:\n\t\t\t\tgController.sky[idx].extendPercent := REAL_TO_WORD(percent * 65535 / 100);\n\t\t\t\tgController.sky[idx].retractPercent := 0;\n\t\tEND_CASE\n\tTargetDirect.retract:\n\t\tCASE level OF\n\t\t\t1:\n\t\t\t\tgController.grd[idx].extendPercent := 0;\n\t\t\t\tgController.grd[idx].retractPercent := REAL_TO_WORD(ABS(percent) * 65535 / 100);\n\t\t\t2:\n\t\t\t\tgController.sky[idx].extendPercent := 0;\n\t\t\t\tgController.sky[idx].retractPercent := REAL_TO_WORD(ABS(percent) * 65535 / 100);\n\t\tEND_CASE\n\tTargetDirect.stop:\n\t\tCASE level OF\n\t\t\t1:\n\t\t\t\tgController.grd[idx].extendPercent := 0;\n\t\t\t\tgController.grd[idx].retractPercent := 0;\n\t\t\t2:\n\t\t\t\tgController.sky[idx].extendPercent := 0;\n\t\t\t\tgController.sky[idx].retractPercent := 0;\n\t\tEND_CASE\nEND_CASE\n```"], ["```\nVAR\nEND_VAR\n\nIF direct = TargetDirect.Extend THEN\n\tCASE level OF\n\t\t1:\n\t\t\tgController.grd[idx].extendPercent := REAL_TO_WORD(percent * 65535 / 100);\n\t\t\tgController.grd[idx].retractPercent := 0;\n\t\t2:\n\t\t\tgController.sky[idx].extendPercent := REAL_TO_WORD(percent * 65535 / 100);\n\t\t\tgController.sky[idx].retractPercent := 0;\n\tEND_CASE\nELSIF direct = TargetDirect.Retract THEN\n\tCASE level OF\n\t\t1:\n\t\t\tgController.grd[idx].extendPercent := 0;\n\t\t\tgController.grd[idx].retractPercent := REAL_TO_WORD(percent * 65535 / 100);\n\t\t2:\n\t\t\tgController.sky[idx].extendPercent := 0;\n\t\t\tgController.sky[idx].retractPercent := REAL_TO_WORD(percent * 65535 / 100);\n\tEND_CASE\nEND_IF\n```"], ["```\nVAR\n\tlineCount\t: INT;\n\tfileHandle  : DWORD;\n\tfileName\t: STRING;\n\tdatetime\t: DATE_AND_TIME;\n\tUdIntms \t: UDINT;\n\tUdMsOffset  : UDINT;\n\tDTimer_Str  : STRING;\n\tuiYear \t\t: UINT; \n\tuiMonth \t: UINT; \n\tuiDay \t\t: UINT; \n\tuiHour \t\t: UINT; \n\tuiMinute \t: UINT; \n\tuiSecond \t: UINT;\t\n\tuiMsSecond\t: UINT;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\n\nIF fileHandle = 0 THEN\n\tdatetime := SysTimeGetDateAndTime();\n\tuiYear := DT_TO_DATE(datetime).year;\n\tuiMonth := DT_TO_DATE(datetime).month;\n\tuiDay := DT_TO_DATE(datetime).day;\n\tuiHour := DT_TO_TIME(datetime).hour;\n\tuiMinute := DT_TO_TIME(datetime).minute;\n\tuiSecond := DT_TO_TIME(datetime).second;\n\tuiMsSecond := DT_TO_TIME(datetime).millisecond;\n\n\tDTimer_Str := concat(INT_TO_STRING(uiYear), '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiMonth));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiDay));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiHour));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiMinute));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiSecond));\n\n\tfileName := concat(filePath, '/');\n\tfileName := concat(fileName, DTimer_Str);\n\tfileName := concat(fileName, '.txt');\n\n\tfileHandle := SysFileOpen(fileName, 'w', F_err);\n\tIF F_err <> 0 THEN\n\t\tfileHandle := 0;\n\tEND_IF;\nEND_IF;\n```"], ["```\nVAR\n\tlineCount\t: INT;\n\tfileHandle  : DWORD;\n\tfileName\t: STRING;\n\tfileHandle0 : DWORD;\n\tdatetime\t: DATE_AND_TIME;\n\tUdIntms \t: UDINT;\n\tUdMsOffset  : UDINT;\n\tDTimer_Str  : STRING;\n\tuiYear \t\t: UINT; \n\tuiMonth \t: UINT; \n\tuiDay \t\t: UINT; \n\tuiHour \t\t: UINT; \n\tuiMinute \t: UINT; \n\tuiSecond \t: UINT;\t\n\tuiMsSecond\t: UINT;\n\n\tS_Time64\t\t: SysTime64;\n\tSTT\t\t\t\t: CurTimeEx;\n\tS_Time\t\t\t: SystemTimeDate;\n\tTime_Str\t\t: STRING;\n\tF_err\t\t\t: DWORD;\n\tF_HANDL\t\t\t: DWORD;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\n\nSTT(SystemTime:= S_Time64, TimeDate:= S_Time);\n\nIF fileHandle = 0 THEN\n\tdatetime := SysTimeGetDateAndTime();\n\tuiYear := datetime.YEAR;\n\tuiMonth := datetime.MONTH;\n\tuiDay := datetime.DAY;\n\tuiHour := datetime.HOUR;\n\tuiMinute := datetime.MINUTE;\n\tuiSecond := datetime.SECOND;\n\tuiMsSecond := datetime.MILLISECOND;\n\n\tTime_Str := concat(INT_TO_STRING(uiYear), '-');\n\tTime_Str := concat(Time_Str, INT_TO_STRING(uiMonth));\n\tTime_Str := concat(Time_Str, '-');\n\tTime_Str := concat(Time_Str, INT_TO_STRING(uiDay));\n\tTime_Str := concat(Time_Str, '_');\n\tTime_Str := concat(Time_Str, INT_TO_STRING(uiHour));\n\tTime_Str := concat(Time_Str, '-');\n\tTime_Str := concat(Time_Str, INT_TO_STRING(uiMinute));\n\tTime_Str := concat(Time_Str, '-');\n\tTime_Str := concat(Time_Str, INT_TO_STRING(uiSecond));\n\n\tfileName := concat(filePath, '/');\n\tfileName := concat(fileName, devName);\n\tfileName := concat(fileName, '_');\n\tfileName := concat(fileName, Time_Str);\n\tfileName := concat(fileName, '.txt');\n\n\tfileHandle := SysFileOpen(fileName, 'w', F_err);\n\tIF F_err <> 0 THEN\n\t\tfileHandle := 0;\n\tEND_IF;\nEND_IF;\n```"], ["```\nVAR\n\tlineCount\t: INT;\n\tfileHandle  : DWORD;\n\tfileName\t: STRING;\n\tfileHandle0 : DWORD;\n\tdatetime\t: DATE_AND_TIME;\n\tUdIntms \t: UDINT;\n\tUdMsOffset  : UDINT;\n\tDTimer_Str  : STRING;\n\tuiYear \t\t: UINT; \n\tuiMonth \t: UINT; \n\tuiDay \t\t: UINT; \n\tuiHour \t\t: UINT; \n\tuiMinute \t: UINT; \n\tuiSecond \t: UINT;\t\n\tuiMsSecond\t: UINT;\n\n\tS_Time64\t\t: SysTime64;\n\tSTT\t\t\t\t: CurTimeEx;\n\tS_Time\t\t\t: SystemTimeDate;\n\tTime_Str\t\t: STRING;\n\tF_err\t\t\t: DWORD;\n\tF_HANDL\t\t\t: DWORD;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\n\nSTT(SystemTime := S_Time64, TimeDate := S_Time);\n\nIF fileHandle = 0 THEN\n\tdatetime := SysTimeGetDateAndTime();\n\tuiYear := datetime.YEAR;\n\tuiMonth := datetime.MONTH;\n\tuiDay := datetime.DAY;\n\tuiHour := datetime.HOUR;\n\tuiMinute := datetime.MINUTE;\n\tuiSecond := datetime.SECOND;\n\tuiMsSecond := datetime.MILLISECOND;\n\n\tDTimer_Str := concat(INT_TO_STRING(uiYear), '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiMonth));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiDay));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiHour));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiMinute));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiSecond));\n\tDTimer_Str := concat(DTimer_Str, '_');\n\tDTimer_Str := concat(DTimer_Str, INT_TO_STRING(uiMsSecond));\n\n\tfileName := concat(filePath, '/');\n\tfileName := concat(fileName, devName);\n\tfileName := concat(fileName, '_');\n\tfileName := concat(fileName, DTimer_Str);\n\tfileName := concat(fileName, '.txt');\n\n\tF_HANDL := SysFileOpen(fileName, 'w', F_err);\n\tIF F_err = 0 THEN\n\t\tfileHandle := F_HANDL;\n\t\tlineCount := 0;\n\tELSE\n\t\tfileHandle := 0;\n\tEND_IF;\nEND_IF;\n```"], ["```python\nVAR\n\tlineCount\t: INT;\n\tfileHandle  : DWORD;\n\tfileName\t: STRING;\n\tdata\t\t: STRING;\n\tF_err\t\t: DWORD;\n\ttempInt\t\t: INT;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\n\n# Check if the file handle is valid\nIF fileHandle = 0 THEN\n\t# Attempt to open the file for writing\n\tfileHandle := SysFileOpen(filePath, 'w', F_err);\n\tIF F_err <> 0 THEN\n\t\t# Handle file open error\n\t\tRETURN;\n\tEND_IF;\nEND_IF;\n\n# Increment the line count and calculate the time interval\nlineCount := lineCount + 1;\ntempInt := lineCount * intervalt;\n\n# Construct the data string\ndata := INT_TO_STRING(lineCount);\ndata := concat(data, '$T$T');\ndata := concat(data, INT_TO_STRING(tempInt));\nIF tempInt < 1000 THEN\n\tdata := concat(data, '$T');\nEND_IF;\ndata := concat(data, '$T$T');\ndata := concat(data, INT_TO_STRING(positionInt));\ndata := concat(data, '$T');\ndata := concat(data, INT_TO_STRING(speedInt));\ndata := concat(data, '$T');\ndata := concat(data, INT_TO_STRING(stateInt));\ndata := concat(data, '$R');\n\n# Write the data to the file\nSysFileWrite(hFile := fileHandle, pData := ADR(data), size := SIZEOF(data), F_err);\nIF F_err <> 0 THEN\n\t# Handle file write error\n\tRETURN;\nEND_IF;\n\n# Optionally close the file if needed\nIF lineCount >= 100 THEN\n\tSysFileClose(hFile := fileHandle);\n\tfileHandle := 0;\nEND_IF;\n```"], ["```\nVAR_OUTPUT\n\tresult\t\t:TargetDirect;\nEND_VAR\n\nIF input = TargetDirect.extend THEN\n\tresult := TargetDirect.retract;\nELSIF input = TargetDirect.retract THEN\n\tresult := TargetDirect.extend;\nELSE\n\tresult := input; // Default case, return the input as is\nEND_IF;\n```\n\nThis continuation completes the `cmdReverse` function by adding an output variable `result` and implementing the logic to reverse the `TargetDirect` input. If the input is neither `extend` nor `retract`, it defaults to returning the input unchanged."], ["It seems like you are working with a Modbus-related system and defining logic for mapping between physical and logical indices for different sections. Based on the provided code fragments, I will continue writing the `mdbsLogicToPhy` function block to complete the logic for mapping logical indices to physical indices.\n\n```st\nVAR\nEND_VAR\n\n(**\n * \u8f93\u5165\u534e\u4e2d\u5730\u5740\u7f16\u53f7\uff0c\u8fd4\u56de\u672c\u5730\u7d22\u5f15\u7f16\u53f7\n *)\nCASE section OF\n    1: // \u533a\u57df\u9650\u5b9a(1:skyExtend)\n        CASE lgcIdx OF\n            10: \n                phyIdx := 1;  // sky1e -> \u6a2a1\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            11: \n                phyIdx := 2;  // sky2e -> \u6a2a2\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            12: \n                phyIdx := 3;  // sky3e -> \u6a2a3\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            13: \n                phyIdx := 4;  // sky4e -> \u6a2a4\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            14: \n                phyIdx := 5;  // sky5e -> \u6a2a5\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            15: \n                phyIdx := 6;  // sky6e -> \u6a2a6\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            16: \n                phyIdx := 7;  // sky7e -> \u6a2a7\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            17: \n                phyIdx := 8;  // sky8e -> \u6a2a8\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            18: \n                phyIdx := 9;  // sky9e -> \u6a2a9\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n            19: \n                phyIdx := 10; // sky10e -> \u6a2a10\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Horizontal;\n        END_CASE\n    2: // \u533a\u57df\u9650\u5b9a(2:skyRetract)\n        CASE lgcIdx OF\n            20: \n                phyIdx := 1;  // sky1r -> \u7eb51\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            21: \n                phyIdx := 2;  // sky2r -> \u7eb52\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            22: \n                phyIdx := 3;  // sky3r -> \u7eb53\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            23: \n                phyIdx := 4;  // sky4r -> \u7eb54\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            24: \n                phyIdx := 5;  // sky5r -> \u7eb55\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            25: \n                phyIdx := 6;  // sky6r -> \u7eb56\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            26: \n                phyIdx := 7;  // sky7r -> \u7eb57\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            27: \n                phyIdx := 8;  // sky8r -> \u7eb58\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            28: \n                phyIdx := 9;  // sky9r -> \u7eb59\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n            29: \n                phyIdx := 10; // sky10r -> \u7eb510\n                level := 2;   // \u5929\u8f68\n                direct := TargetDirect.Vertical;\n        END_CASE\n    3: // \u533a\u57df\u9650\u5b9a(3:groundExtend)\n        CASE lgcIdx OF\n            223: \n                phyIdx := 1;  // grd1e -> \u6a2a1\n                level := 1;   // \u5730\u8f68\n                direct := TargetDirect.Horizontal;\n            231: \n                phyIdx := 2;  // grd2e -> \u7eb51\n                level := 1;   // \u5730\u8f68\n               "], ["```\nVAR\nEND_VAR\n\n(**\n * \u5c06\u8bbe\u5907\u7f16\u53f7\u89e3\u6790\u4e3a\u5bf9\u5e94\u7684\u5c42\u7ea7\u548c\u7d22\u5f15\n * (level:1->\u5730\u8f68\t2->\u5929\u8f68)(idx:\u5185\u5b58\u7269\u7406\u5730\u5740\u5bf9\u5e94\u6570\u7ec4\u7d22\u5f15)\n *)\nCASE devNo OF\n\t1..10: // \u5730\u8f68\u8bbe\u5907\u7f16\u53f7\u8303\u56f4\n\t\tlevel := 1; // \u5730\u8f68\n\t\tidx := devNo; // \u7d22\u5f15\u76f4\u63a5\u5bf9\u5e94\u8bbe\u5907\u7f16\u53f7\n\t11..20: // \u5929\u8f68\u8bbe\u5907\u7f16\u53f7\u8303\u56f4\n\t\tlevel := 2; // \u5929\u8f68\n\t\tidx := devNo - 10; // \u7d22\u5f15\u4e3a\u8bbe\u5907\u7f16\u53f7\u51cf\u53bb\u504f\u79fb\u91cf\nELSE\n\t// \u9ed8\u8ba4\u503c\u5904\u7406\n\tlevel := 0; // \u672a\u5b9a\u4e49\u5c42\u7ea7\n\tidx := -1; // \u65e0\u6548\u7d22\u5f15\nEND_CASE;\n```"], ["It seems like you are working with a Modbus-related project, and the provided code fragments are written in Structured Text (ST), commonly used in industrial automation systems. Below is the continuation of the `FUNCTION_BLOCK mdbsPhyToLogic` based on the patterns and logic observed in the provided code fragments:\n\n```st\nVAR\nEND_VAR\n\n(**\n * \u5c06\u5185\u5b58\u7269\u7406\u5730\u5740\u7d22\u5f15\u89e3\u6790\u4e3a\u534e\u4e2d\u72b6\u6001\u5730\u5740\n * (lgcIdx: \u534e\u4e2d\u5bf9\u5e94\u7684\u5730\u5740)\n *)\nCASE section OF\n    1: // \u533a\u57df\u9650\u5b9a1: grdExt\n        CASE phyIdx OF\n            1:  lgcIdx := 127;   // \u5730\u8f681 -> \u534e\u4e2d\u5730\u5740127\n            2:  lgcIdx := 128;   // \u5730\u8f682 -> \u534e\u4e2d\u5730\u5740128\n            3:  lgcIdx := 129;   // \u5730\u8f683 -> \u534e\u4e2d\u5730\u5740129\n            4:  lgcIdx := 130;   // \u5730\u8f684 -> \u534e\u4e2d\u5730\u5740130\n            5:  lgcIdx := 131;   // \u5730\u8f685 -> \u534e\u4e2d\u5730\u5740131\n            6:  lgcIdx := 132;   // \u5730\u8f686 -> \u534e\u4e2d\u5730\u5740132\n            7:  lgcIdx := 133;   // \u5730\u8f687 -> \u534e\u4e2d\u5730\u5740133\n            8:  lgcIdx := 134;   // \u5730\u8f688 -> \u534e\u4e2d\u5730\u5740134\n            9:  lgcIdx := 135;   // \u5730\u8f689 -> \u534e\u4e2d\u5730\u5740135\n            10: lgcIdx := 136;   // \u5730\u8f6810 -> \u534e\u4e2d\u5730\u5740136\n        END_CASE;\n\n    2: // \u533a\u57df\u9650\u5b9a2: grdRet\n        CASE phyIdx OF\n            1:  lgcIdx := 175;   // \u5730\u8f681 -> \u534e\u4e2d\u5730\u5740175\n            2:  lgcIdx := 176;   // \u5730\u8f682 -> \u534e\u4e2d\u5730\u5740176\n            3:  lgcIdx := 177;   // \u5730\u8f683 -> \u534e\u4e2d\u5730\u5740177\n            4:  lgcIdx := 178;   // \u5730\u8f684 -> \u534e\u4e2d\u5730\u5740178\n            5:  lgcIdx := 179;   // \u5730\u8f685 -> \u534e\u4e2d\u5730\u5740179\n            6:  lgcIdx := 180;   // \u5730\u8f686 -> \u534e\u4e2d\u5730\u5740180\n            7:  lgcIdx := 181;   // \u5730\u8f687 -> \u534e\u4e2d\u5730\u5740181\n            8:  lgcIdx := 182;   // \u5730\u8f688 -> \u534e\u4e2d\u5730\u5740182\n            9:  lgcIdx := 183;   // \u5730\u8f689 -> \u534e\u4e2d\u5730\u5740183\n            10: lgcIdx := 184;   // \u5730\u8f6810 -> \u534e\u4e2d\u5730\u5740184\n        END_CASE;\n\n    3: // \u533a\u57df\u9650\u5b9a3: skyExt\n        CASE phyIdx OF\n            1:  lgcIdx := 223;   // \u5929\u8f681 -> \u534e\u4e2d\u5730\u5740223\n            2:  lgcIdx := 224;   // \u5929\u8f682 -> \u534e\u4e2d\u5730\u5740224\n            3:  lgcIdx := 225;   // \u5929\u8f683 -> \u534e\u4e2d\u5730\u5740225\n            4:  lgcIdx := 226;   // \u5929\u8f684 -> \u534e\u4e2d\u5730\u5740226\n            5:  lgcIdx := 227;   // \u5929\u8f685 -> \u534e\u4e2d\u5730\u5740227\n            6:  lgcIdx := 228;   // \u5929\u8f686 -> \u534e\u4e2d\u5730\u5740228\n            7:  lgcIdx := 229;   // \u5929\u8f687 -> \u534e\u4e2d\u5730\u5740229\n            8:  lgcIdx := 230;   // \u5929\u8f688 -> \u534e\u4e2d\u5730\u5740230\n            9:  lgcIdx := 231;   // \u5929\u8f689 -> \u534e\u4e2d\u5730\u5740231\n            10: lgcIdx := 232;   // \u5929\u8f6810 -> \u534e\u4e2d\u5730\u5740232\n        END_CASE;\n\n    4: // \u533a\u57df\u9650\u5b9a4: skyRet\n        CASE phyIdx OF\n            1:  lgcIdx := 271;   // \u5929\u8f681 -> \u534e\u4e2d\u5730\u5740271\n            2:  lgcIdx := 272;   // \u5929\u8f682 -> \u534e\u4e2d\u5730\u5740272\n            3:  lgcIdx := 273;   // \u5929\u8f683 -> \u534e\u4e2d\u5730\u5740273\n            4:  lgcIdx := 274;   // \u5929\u8f684 -> \u534e\u4e2d\u5730\u5740274\n            5:  lgcIdx := 275;   // \u5929\u8f685 -> \u534e\u4e2d\u5730\u5740275\n            6:  lgcIdx := 276;   // \u5929\u8f686 -> \u534e\u4e2d\u5730\u5740276\n            "], ["```pascal\nVAR\n    success : BOOL;\nEND_VAR\n\nCASE direct OF\n    TargetDirect.extend:\n        CASE level OF\n            1: // \u5730\u8f68\n                gController.grd[idx].extendPercent := 65535; // 100% \u4f38\u51fa\n                gController.grd[idx].retractPercent := 0;    // \u7f29\u56de\u8bbe\u4e3a 0%\n                success := TRUE;\n            2: // \u5929\u8f68\n                gController.sky[idx].extendPercent := 65535; // 100% \u4f38\u51fa\n                gController.sky[idx].retractPercent := 0;    // \u7f29\u56de\u8bbe\u4e3a 0%\n                success := TRUE;\n            ELSE\n                success := FALSE; // \u65e0\u6548\u7684 level\n        END_CASE\n    TargetDirect.retract:\n        CASE level OF\n            1: // \u5730\u8f68\n                gController.grd[idx].extendPercent := 0;    // \u4f38\u51fa\u8bbe\u4e3a 0%\n                gController.grd[idx].retractPercent := 65535; // 100% \u7f29\u56de\n                success := TRUE;\n            2: // \u5929\u8f68\n                gController.sky[idx].extendPercent := 0;    // \u4f38\u51fa\u8bbe\u4e3a 0%\n                gController.sky[idx].retractPercent := 65535; // 100% \u7f29\u56de\n                success := TRUE;\n            ELSE\n                success := FALSE; // \u65e0\u6548\u7684 level\n        END_CASE\n    ELSE\n        success := FALSE; // \u65e0\u6548\u7684 direct\nEND_CASE\n\nsetButtonByDirect := success;\n```"]]