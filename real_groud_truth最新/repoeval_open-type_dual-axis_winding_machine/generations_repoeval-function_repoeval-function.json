[["```\nVAR\nEND_VAR\n\nIF lM >= lL AND lM <= lH THEN\n    lF := lM;\nELSE\n    IF lM < lL THEN\n        lF := lL;\n    ELSE\n        lF := lH;\n    END_IF\nEND_IF\n```"], ["```\n# --------------------------------------------------\n# FUNCTION F_CalculateRadius : LREAL\n# VAR_INPUT\n# \tlD\t\t\t\t:\tLREAL;\t\t//\u4e24\u8f74\u4e2d\u5fc3\u8ddd\u79bb\n# \tlHold\t\t\t:\tLREAL;\t\t//\u6d4b\u91cf\u5f00\u59cb\u65f6\u7684AxisV\u4f4d\u7f6e\n# \tlHnew\t\t\t:\tLREAL;\t\t//\u6d4b\u91cf\u7ed3\u675f\u65f6\u7684AxisV\u4f4d\u7f6e\n# \tlTk\t\t\t\t:\tLREAL;\t\t//\u6750\u6599\u539a\u5ea6\n# \tlOffset\t\t\t:\tLREAL;\t\t//\u9ad8\u5ea6\u504f\u79fb\u91cf\n# END_VAR\n# \n# // \u8ba1\u7b97\u4ece\u8f74\u534a\u5f84\n# IF (lHnew - lHold) > 0.01 THEN  // \u907f\u514d\u9664\u96f6\n# \tF_CalculateRadius := lD / 2 + (lHnew - lHold) / 2 + lTk + lOffset;\n# ELSE\n# \tF_CalculateRadius := lD / 2 + lTk + lOffset;\n# END_IF\n# --------------------------------------------------\n# the below code fragment can be found in:\n# \u5f00\u653e\u5f0f\u53cc\u8f74\u5377\u7ed5\u673a\u7f16\u7a0b\u5f00\u53d1\u5b9e\u8bad-PRG\\PLC_PRG.st\n# --------------------------------------------------\n# \t\t\t// \u4f7f\u7528F_CalculateRadius\u51fd\u6570\u8ba1\u7b97\u4ece\u8f74\u534a\u5f84\n# \t\t\tSr := F_CalculateRadius(lD := AxisDistance, lHold := AxisVStart, lHnew := AxisVEnd, lTk := MaterialThickness, lOffset := HeightOffset);\n# \n# \t\t\t// \u8c03\u7528F_CompensateVelocity\u51fd\u6570\u8ba1\u7b97\u901f\u5ea6\u8865\u507f\n# \t\t\tCompensatedVelocity := F_CompensateVelocity(lCurrentVel := CurrentVelocity, lOldPos := OldPosition, lNewPos := NewPosition, lRadius := Sr, lTk := MaterialThickness, bUnwinding := IsUnwinding);\n```"], ["```\n// Velocity compensation formula:\n// V_compensated = V_current * (R_old / R_new)\n\nVAR\n    lOldRadius : LREAL; // Previous radius\n    lNewRadius : LREAL; // Current radius\nEND_VAR\n\n// Calculate the old and new radii based on the positions and material thickness\nlOldRadius := ABS(SQRT(EXPT(lRadius, 2) + EXPT(lOldPos, 2)) - SQRT(EXPT(lRadius, 2) + EXPT(lOldPos - lTk, 2))) / SMC_PI + lTk;\nlNewRadius := ABS(SQRT(EXPT(lRadius, 2) + EXPT(lNewPos, 2)) - SQRT(EXPT(lRadius, 2) + EXPT(lNewPos - lTk, 2))) / SMC_PI + lTk;\n\n// Adjust velocity based on unwinding or winding direction\nIF bUnwinding THEN\n    F_CompensateVelocity := lCurrentVel * (lOldRadius / lNewRadius);\nELSE\n    F_CompensateVelocity := lCurrentVel * (lNewRadius / lOldRadius);\nEND_IF;\n```"], ["```\nVAR\n\t_fbMoveVel\t:\tMC_MoveVelocity;\n\t_fbMoveAbs\t:\tMC_MoveAbsolute;\n\t_fbHalt\t\t:\tMC_Halt;\n\t_fbSetPos\t:\tMC_SetPosition;\n\t_fbRtrig\t\t:\tR_TRIG;\n\t_fbFtrig\t\t:\tF_TRIG;\n\t_nBDirection\t:\tMC_DIRECTION;\n\t_fTempPos\t\t:\tLREAL;\n\t_nState\t\t:\tUSINT;\nEND_VAR\n\nMETHOD FAST_ZERO\nVAR_IN_OUT \n\t_Axis\t:\tAXIS_REF_SM3;\nEND_VAR\nVAR_INPUT\n\t_xHome\t:\tBOOL;\n\t_xAbort\t:\tBOOL;\n\t_nHomeMode\t:\tHomeMode;\n\t_fFastHomeVel\t:\tLREAL;\n\t_fSlowHomeVel\t:\tLREAL;\n\t_fHomeAcc\t\t:\tLREAL;\n\t_fHomeDec\t\t:\tLREAL;\n\t_fHomePos\t\t:\tLREAL;\n\t_xReferenceSwitch\t:\tBOOL;//typically is true\n\t_nDirection\t:\tMC_DIRECTION;\n\t_xIndexPulse\t:\tBOOL;\nEND_VAR\nVAR_OUTPUT\n\t_xBusy\t:\tBOOL;\n\t_xDone\t:\tBOOL;\n\t_xErr\t:\tBOOL;\n\t_iErrId\t:\tDINT;\nEND_VAR\nVAR\n\t_fbMoveVel\t:\tMC_MoveVelocity;\n\t_fbMoveAbs\t:\tMC_MoveAbsolute;\n\t_fbHalt\t\t:\tMC_Halt;\n\t_fbSetPos\t:\tMC_SetPosition;\n\t_fbRtrig\t\t:\tR_TRIG;\n\t_fbFtrig\t\t:\tF_TRIG;\n\t_nBDirection\t:\tMC_DIRECTION;\n\t_fTempPos\t\t:\tLREAL;\n\t_nState\t\t:\tUSINT;\nEND_VAR\n\nCASE _nState OF\n\t0: // Initialization\n\t\t_xBusy := TRUE;\n\t\t_xDone := FALSE;\n\t\t_xErr := FALSE;\n\t\t_iErrId := 0;\n\t\t_nState := 1;\n\n\t1: // Check Home Condition\n\t\tIF _xHome THEN\n\t\t\t_fbRtrig(CLK := _xHome);\n\t\t\tIF _fbRtrig.Q THEN\n\t\t\t\t_nState := 2;\n\t\t\tEND_IF;\n\t\tEND_IF;\n\n\t2: // Execute Fast Home Velocity\n\t\t_fbMoveVel(Axis := _Axis, Velocity := _fFastHomeVel, Acceleration := _fHomeAcc, Deceleration := _fHomeDec, Direction := _nDirection);\n\t\tIF _fbMoveVel.Done THEN\n\t\t\t_nState := 3;\n\t\tEND_IF;\n\n\t3: // Execute Slow Home Velocity\n\t\t_fbMoveVel(Axis := _Axis, Velocity := _fSlowHomeVel, Acceleration := _fHomeAcc, Deceleration := _fHomeDec, Direction := _nDirection);\n\t\tIF _fbMoveVel.Done THEN\n\t\t\t_nState := 4;\n\t\tEND_IF;\n\n\t4: // Set Position\n\t\t_fbSetPos(Axis := _Axis, Position := _fHomePos);\n\t\tIF _fbSetPos.Done THEN\n\t\t\t_nState := 5;\n\t\tEND_IF;\n\n\t5: // Complete\n\t\t_xBusy := FALSE;\n\t\t_xDone := TRUE;\n\t\t_nState := 0;\n\nELSE\n\t_xErr := TRUE;\n\t_iErrId := -1; // Error ID\nEND_CASE;\n```"], ["```\nVAR\n\t_nState : USINT;\nEND_VAR\n\n// Implementation of the StaDisplay function block\n// This function block is used to display the status of the machine using output signals Y1 to Y6.\nMETHOD DisplayStatus : VOID\nVAR_INPUT\n\tiStatus : INT; // Input status code\nEND_VAR\nVAR_OUTPUT\n\tY1, Y2, Y3, Y4, Y5, Y6 : BOOL; // Output signals representing different status indicators\nEND_VAR\n\n// Reset all output signals to FALSE initially\nY1 := FALSE;\nY2 := FALSE;\nY3 := FALSE;\nY4 := FALSE;\nY5 := FALSE;\nY6 := FALSE;\n\n// Set the corresponding output signal based on the input status code\nCASE iStatus OF\n\t1: Y1 := TRUE; // Status 1 - Activate Y1\n\t2: Y2 := TRUE; // Status 2 - Activate Y2\n\t3: Y3 := TRUE; // Status 3 - Activate Y3\n\t4: Y4 := TRUE; // Status 4 - Activate Y4\n\t5: Y5 := TRUE; // Status 5 - Activate Y5\n\t6: Y6 := TRUE; // Status 6 - Activate Y6\n\tELSE\n\t\t// If the status code is not recognized, keep all outputs FALSE\nEND_CASE;\n```"]]