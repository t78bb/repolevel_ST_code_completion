import os
import re
import json
import time
from pathlib import Path
from typing import List, Optional
from codesys_debug import CodesysCompiler, ResponseData, ErrorMessage
from library_recommender import recommend_library_snippets

# CODESYS API 配置 - 优先使用环境变量，否则使用默认值
CODESYS_API_URL = os.getenv("CODESYS_API_URL", "http://192.168.103.117:9000/api/v1/pou/workflow")

# 智增增API配置 - 必须从环境变量读取
ZHIZENGZENG_API_KEY = os.getenv("ZHIZENGZENG_API_KEY")
ZHIZENGZENG_BASE_URL = os.getenv("ZHIZENGZENG_BASE_URL", "https://api.zhizengzeng.com/v1")

#暂时冻结不用的prompt:
#- If you find  "END_FUNCTION" or "END_FUNCTION_BLOCK" in the end of the code, remove it.


# 从verifier_agent.py中提取的prompt模板
verifier_system_prompt = """
ROLE: 
You are an expert in Structured Text (ST) programming for IEC 61131-3-compliant PLCs using the Codesys development environment. 
You specialize in identifying and correcting syntax and semantic errors based on compiler feedback generated by Codesys.

GOALS: 
Generate accurate patch fixes that are syntactically and semantically correct within the Codesys environment.

WORKFLOW:
1. Analyze the compiler error messages provided by the Codesys IDE and locate the actual erroneous ST code segment.
2. Explain why the error occurred using IEC 61131-3 rules and Codesys-specific language semantics.
3. Provide detailed and actionable corrective suggestions for each identified issue.
4. Output a patch using the following required format.

IMPORTANT:
- Assume compilation is performed within the Codesys environment, targeting platforms such as Beckhoff, WAGO, or Schneider Electric PLCs.
- <code_segment> must be a verbatim copy of the original ST code, including indentation and comments.
- <patch> must be a direct replacement for the code segment and must be syntactically valid for Structured Text in Codesys.
- Clearly identify violated syntax rules, common function block misuse, or incorrect data typing.
- Consider that some compiler errors may cascade—reason about task execution flow and variable scope to identify the root issue.
- Avoid altering the original control logic or behavior unless absolutely necessary for correctness.
- If you find a "BEGIN" between the variable declarations and the code logic section, remove it.
- Do not use variables that are not declared in the declaration section.


OUTPUT FORMAT:
```plaintext
- Fix suggestion 1: [Clear and actionable error fix suggestion]
- Fix suggestion k: [Clear and actionable error fix suggestion]
(1)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
(n)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
```

--Appendix--
ST Library Functions:
{api_details}
ST Programming Guidelines:
{programming_guidance}
"""

#user prompt
verifier_instance_prompt = """
If it is not possible to ensure that all variables are declared, no new variables shall be added; repairs shall only be implemented by modifying existing variables/logic.
Input structured in XML format:
<!-- Code with errors. -->
<STCode>
{st_code}
</STCode>
<!-- Errors. -->
<Errors>
{static_analysis_results}
</Errors>
<!-- Error information of the library function that caused the call failure. -->
<library_function_infos>
{function_infos}
</library_function_infos>
"""

programming_guidance = "NO PROGRAMMING GUIDANCE"


def extract_content(response) -> str:
    """
    提取响应内容中的st代码。
    支持多种响应格式。
    """
    if hasattr(response, 'choices'):
        choice = response.choices[0]
        if hasattr(choice, 'message') and hasattr(choice.message, 'content'):
            st_code = choice.message.content
        else:
            st_code = choice['message']['content']
    elif hasattr(response, 'content'):
        st_code = response.content[0].text if isinstance(response.content, list) else response.content
    elif isinstance(response, str):
        st_code = response
    else:
        st_code = str(response)
    return st_code


def parse_patch(text: str) -> List[tuple]:
    """
    解析给定文本中的代码段和补丁。
    
    返回:
    - List[tuple] - 一个包含多个元组的列表，每个元组包含两个字符串：
      1. buggy 代码（修复前的代码）。
      2. patch（修复该问题的补丁）。
    """
    # 编译一个正则表达式模式，用于匹配<code_segment>和<patch>标签之间的内容。
    pattern = re.compile(
        r'<code_segment>(.*?)</code_segment>\s*<patch>(.*?)</patch>', 
        re.DOTALL
    )
    
    # 使用编译的正则表达式查找所有匹配项。
    matches = pattern.findall(text)

    def _normalize_indent(code: str) -> str:
        """
        将每行行首的缩进（空格和 Tab）视作列宽，统一缩减为一半，并全部转换为空格。
        - 空格算 1 列，Tab 算 4 列。
        - 仅处理行首的连续空白，不改动行中间的空格/Tab。
        """
        lines = code.splitlines()
        norm_lines: List[str] = []
        for line in lines:
            # 统计行首空白列数（空格=1，Tab=4）
            leading_cols = 0
            idx = 0
            while idx < len(line) and line[idx] in (" ", "\t"):
                if line[idx] == " ":
                    leading_cols += 1
                else:  # '\t'
                    leading_cols += 4
                idx += 1

            if leading_cols > 0:
                new_cols = max(0, leading_cols // 2)  # 缩减为一半
                line = " " * new_cols + line[idx:]
            norm_lines.append(line)
        return "\n".join(norm_lines)

    results = []
    for buggy, patch in matches:
        # 先做缩进归一化，再去除首尾空白
        buggy_norm = _normalize_indent(buggy)
        patch_norm = _normalize_indent(patch)
        results.append((buggy_norm.strip(), patch_norm.strip()))
    
    # 返回处理后的结果列表。
    return results


def call_llm_for_fix(messages: List[dict], llm_client=None, use_openai: bool = False, 
                     openai_api_key: Optional[str] = None, model: str = "gpt-4o",
                     base_url: Optional[str] = None) -> str:
    """
    调用大模型进行代码修复。
    
    参数:
    - messages: 消息列表，格式为 [{"role": "system", "content": "..."}, ...]
    - llm_client: 自定义的LLM客户端对象，如果有则使用它
    - use_openai: 是否使用openai库（需要安装openai包）
    - openai_api_key: API密钥
    - model: 使用的模型名称
    - base_url: API的基础URL（用于智增增等API中转站），如果为None则使用OpenAI默认URL
    
    返回:
    - str: 模型返回的修复建议文本
    """
    if llm_client is not None:
        # 使用自定义客户端
        if hasattr(llm_client, 'call'):
            response = llm_client.call(messages=messages)
            return extract_content(response)
        elif hasattr(llm_client, '__call__'):
            response = llm_client(messages)
            return extract_content(response)
        else:
            raise ValueError("自定义LLM客户端必须实现call方法或可调用")
    
    if use_openai:
        try:
            import openai
            if base_url:
                # 使用自定义base_url（如智增增API）
                client = openai.OpenAI(
                    api_key=openai_api_key,
                    base_url=base_url
                )
            elif openai_api_key:
                # 使用OpenAI官方API
                client = openai.OpenAI(api_key=openai_api_key)
            else:
                # 尝试从环境变量获取
                client = openai.OpenAI()
            
            response = client.chat.completions.create(
                model=model,
                messages=messages
            )
            return extract_content(response)
        except ImportError:
            raise ImportError("需要安装openai库: pip install openai")
        except Exception as e:
            raise Exception(f"调用API失败: {e}")
    
    # 如果没有提供客户端，返回提示信息
    raise ValueError("请提供llm_client参数或设置use_openai=True并配置openai_api_key")


def auto_fix_st_code(
    st_file_path: str,
    block_name: Optional[str] = None,
    max_verify_count: int = 3,
    ip_port: Optional[str] = None,
    llm_client=None,
    use_openai: bool = False,
    openai_api_key: Optional[str] = None,
    model: str = "gpt-4o",
    base_url: Optional[str] = None,
    api_details: str = "",
    programming_guidance_text: Optional[str] = None,
    version_save_dir: Optional[str] = None
) -> tuple:
    """
    自动修复ST代码的主流程。
    
    参数:
    - st_file_path: test.st文件的路径
    - block_name: 代码块名称，如果为None则从文件内容中提取
    - max_verify_count: 最大验证/修复次数
    - ip_port: CODESYS API地址，如果为None则使用默认值
    - llm_client: 自定义的LLM客户端对象
    - use_openai: 是否使用openai库
    - openai_api_key: API密钥
    - model: 使用的模型名称
    - base_url: API的基础URL（用于智增增等API中转站），如果为None则使用OpenAI默认URL
    - api_details: ST库函数详情（用于system prompt）
    - programming_guidance_text: 编程指导文本（用于system prompt）
    
    返回:
    - tuple: (修复后的代码, 是否成功, 尝试次数)

    额外:
    - 若提供 version_save_dir，则会在该目录下按“文件名_序号.st”保存每次修改后的版本，
      0 表示初始代码，序号与修复轮次一致。
    """
    # 读取test.st文件
    if not os.path.exists(st_file_path):
        raise FileNotFoundError(f"文件不存在: {st_file_path}")
    
    with open(st_file_path, 'r', encoding='utf-8') as f:
        st_code = f.read()
    
    # 如果没有指定block_name，尝试从代码中提取
    if block_name is None:
        # 尝试提取FUNCTION_BLOCK或PROGRAM名称
        match = re.search(r'(?:FUNCTION_BLOCK|PROGRAM|FUNCTION)\s+(\w+)', st_code, re.IGNORECASE)
        if match:
            block_name = match.group(1)
        else:
            block_name = "TestBlock"
    
    # 版本快照保存
    base_filename = os.path.splitext(os.path.basename(st_file_path))[0]
    if version_save_dir:
        os.makedirs(version_save_dir, exist_ok=True)
        def _save_version(code_str: str, suffix: int):
            file_path = os.path.join(version_save_dir, f"{base_filename}_{suffix}.st")
            with open(file_path, 'w', encoding='utf-8') as vf:
                vf.write(code_str)
            print(f"  [版本快照] 已保存: {file_path}")
        _save_version(st_code, 0)  # 保存初始版本
    else:
        def _save_version(code_str: str, suffix: int):
            return

    # 使用默认IP地址
    if ip_port is None:
        ip_port = CODESYS_API_URL
    
    # 初始化编译器实例
    compiler = CodesysCompiler()
    start_time = time.time()
    
    # 构建验证器的系统提示信息
    pg_text = programming_guidance_text if programming_guidance_text is not None else programming_guidance
    verifier_system_prompt_with_data = verifier_system_prompt.format(
        api_details=api_details,
        programming_guidance=pg_text
    )
    
    verifier_messages = [{"role": "system", "content": verifier_system_prompt_with_data}]
    
    # 尝试验证和修复代码，直到成功或达到最大尝试次数
    verify_count = 0
    while verify_count < max_verify_count:
        verify_count += 1
        print(f"\n{'='*60}")
        print(f"第 {verify_count} 次验证尝试")
        print(f"{'='*60}")
        
        # 调用语法检查
        check_result = compiler.syntax_check(block_name, st_code, ip_port)

        no_error = check_result.success
        
        elapsed_time = time.time() - start_time
        print(f"编译耗时: {elapsed_time:.2f} 秒")
        
        if no_error:
            print(f"{block_name} SUCCESS!")
            # print(f"\n最终代码:\n{st_code}")
            return (st_code, True, verify_count)
        else:
            error_list = []
            
            # 首选 Declaration Section 的错误，因为会引发级联错误
            for error in check_result.errors:
                if error.error_type == "Declaration Section Error":
                    print(f"Declaration Error >>> {str(error)}")
                    error_list.append(error.to_dict())
            
            # 如果没有 Declaration Section 的错误，则检查 Implementation Section 的错误
            if not error_list:
                for error in check_result.errors:
                    if error.error_type == "Implementation Section Error":
                        print(f'Implementation Error >>>> {str(error)}')
                        error_list.append(error.to_dict())
            
            # 记录所有错误信息
            all_errors = [error.to_dict() for error in check_result.errors]
            error_log = '\n'.join([str(err) for err in error_list])

            # 基于报错推荐相关库函数信息（名称 + 对应 infos 文件标识）
            lib_snippets = recommend_library_snippets(error_log)
            if lib_snippets:
                # 目前先以简单 JSON 形式提供给大模型，后续可根据需要调整格式
                function_infos = json.dumps(
                    [{"name": name, "info": info} for name, info in lib_snippets],
                    ensure_ascii=False,
                    indent=2,
                )
            else:
                function_infos = ""

            # 准备本轮日志落盘位置（与历史版本同级 logs 目录）
            log_path = None
            log_lines = []
            if version_save_dir:
                logs_dir = Path(version_save_dir).resolve().parent / "logs"
                logs_dir.mkdir(parents=True, exist_ok=True)
                log_path = logs_dir / f"{Path(st_file_path).stem}_round{verify_count}.log"
                log_lines.append(f"[Round {verify_count}] block={block_name}")
                log_lines.append(f"errors_count={len(check_result.errors)}")
                log_lines.append("errors:")
                log_lines.append(error_log if error_log else "(none)")
                log_lines.append("")
            
            print(f'\n{block_name} 发现错误，开始调用大模型修复...')
            print(f"错误总数: {len(check_result.errors)}")
            
            # 构建用户提示
            verifier_instance_prompt_with_data = verifier_instance_prompt.format(
                static_analysis_results=error_log,
                st_code=st_code,
                function_infos=function_infos
            )



            verifier_messages.append({"role": "user", "content": verifier_instance_prompt_with_data})
            
            # 使用AI模型生成修复补丁
            try:
                verify_result = call_llm_for_fix(
                    verifier_messages,
                    llm_client=llm_client,
                    use_openai=use_openai,
                    openai_api_key=openai_api_key,
                    model=model,
                    base_url=base_url
                )
                
                verifier_messages.append({"role": "assistant", "content": verify_result})
                print(f"\n模型返回的修复建议:\n{verify_result}\n")
                if log_path:
                    log_lines.append("llm_response:")
                    log_lines.append(verify_result)
                    log_lines.append("")
                
                # 解析补丁
                segments_and_patches = parse_patch(verify_result)
                
                if not segments_and_patches:
                    print("警告: 未能从模型响应中解析出补丁，跳过本次修复")
                    if log_path:
                        log_lines.append("parse_patch: no patches parsed")
                        log_path.write_text("\n".join(log_lines), encoding="utf-8")
                    continue
                
                # 应用修复补丁到代码中（按行滑动匹配，允许行是子串即可）
                print(f"应用 {len(segments_and_patches)} 个补丁...")
                applied_logs = []
                for buggy, patch in segments_and_patches:
                    code_lines = st_code.splitlines()
                    buggy_lines = buggy.splitlines()
                    if not buggy_lines:
                        applied_logs.append("empty buggy, skipped")
                        continue

                    # 在 st_code 中查找一个起始行，使得 buggy 每行（去首尾空白）都是对应行的子串
                    start_idx = -1
                    for i in range(0, len(code_lines) - len(buggy_lines) + 1):
                        ok = True
                        for j, bline in enumerate(buggy_lines):
                            b = bline.strip()
                            if not b:
                                continue
                            if b not in code_lines[i + j]:
                                ok = False
                                break
                        if ok:
                            start_idx = i
                            break

                    if start_idx == -1:
                        print(f"  ✗ 未找到匹配的代码段，跳过此补丁")
                        print(f"    查找的代码段:\n{buggy}")
                        applied_logs.append("patch not found, skipped")
                        continue

                    end_idx = start_idx + len(buggy_lines)
                    # 用补丁整体替换这段行
                    patch_lines = patch.splitlines()
                    st_code = "\n".join(code_lines[:start_idx] + patch_lines + code_lines[end_idx:])
                    print(f"  ✓ 已应用补丁（行 {start_idx+1}-{end_idx}）")
                    applied_logs.append("applied patch")

                # 保存本轮修复后的版本
                _save_version(st_code, verify_count)
                if log_path:
                    log_lines.append("patch_apply_results:")
                    log_lines.extend(applied_logs)
                    log_path.write_text("\n".join(log_lines), encoding="utf-8")
                
            except Exception as e:
                print(f"调用大模型失败: {e}")
                if log_path:
                    log_lines.append(f"exception: {e}")
                    log_path.write_text("\n".join(log_lines), encoding="utf-8")
                print("跳过本次修复尝试")
                continue
            
            print(f"{block_name} 修复完成 ({verify_count}/{max_verify_count}) - 执行时间: {(time.time() - start_time):.6f} 秒")
    
    # 达到最大尝试次数仍未成功
    print(f"\n{'='*60}")
    print(f"达到最大尝试次数 ({max_verify_count})，停止修复")
    print(f"{'='*60}")
    return (st_code, False, verify_count)


if __name__ == "__main__":
    # 测试代码
    test_st_path = os.path.join(os.path.dirname(__file__), "test.st")
    
    print("=" * 60)
    print("开始自动修复ST代码流程")
    print("=" * 60)
    print(f"读取文件: {test_st_path}")
    
    # 智增增API配置 - 从环境变量读取
    API_KEY = ZHIZENGZENG_API_KEY
    BASE_URL = ZHIZENGZENG_BASE_URL
    
    # 检查API配置
    if not API_KEY or API_KEY == "":
        print("错误: 未配置API密钥！")
        print("请在CMD中设置环境变量:")
        print("  set ZHIZENGZENG_API_KEY=你的API密钥")
        print("  set ZHIZENGZENG_BASE_URL=https://api.zhizengzeng.com/v1")
        exit(1)
    
    print(f"使用API地址: {BASE_URL}")
    print(f"使用模型: gpt-4o")
    
    # 使用智增增API进行自动修复
    fixed_code, success, count = auto_fix_st_code(
        test_st_path,
        max_verify_count=3,
        use_openai=True,
        openai_api_key=API_KEY,
        base_url=BASE_URL,
        model="gpt-4o"  # 可以根据智增增支持的模型调整
    )
    
    if success:
        print(f"\n✓ 修复成功！共尝试 {count} 次")
        # 可选：保存修复后的代码
        output_path = os.path.join(os.path.dirname(__file__), "test_fixed.st")
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(fixed_code)
        print(f"修复后的代码已保存到: {output_path}")
    else:
        print(f"\n✗ 修复失败，已达到最大尝试次数 ({count})")

