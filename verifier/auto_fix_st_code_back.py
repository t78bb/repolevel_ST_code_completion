import os
import re
import json
import time
from typing import List, Optional
from codesys_debug import CodesysCompiler, ResponseData, ErrorMessage

# CODESYS API 配置 - 优先使用环境变量，否则使用默认值
CODESYS_API_URL = os.getenv("CODESYS_API_URL", "http://192.168.103.117:9000/api/v1/pou/workflow")

# 智增增API配置 - 必须从环境变量读取
ZHIZENGZENG_API_KEY = os.getenv("ZHIZENGZENG_API_KEY")
ZHIZENGZENG_BASE_URL = os.getenv("ZHIZENGZENG_BASE_URL", "https://api.zhizengzeng.com/v1")

#暂时冻结不用的prompt:
#- If you find  "END_FUNCTION" or "END_FUNCTION_BLOCK" in the end of the code, remove it.


# 从verifier_agent.py中提取的prompt模板
verifier_system_prompt = """
ROLE: 
You are an expert in Structured Text (ST) programming for IEC 61131-3-compliant PLCs using the Codesys development environment. 
You specialize in identifying and correcting syntax and semantic errors based on compiler feedback generated by Codesys.

GOALS: 
Generate accurate patch fixes that are syntactically and semantically correct within the Codesys environment.

WORKFLOW:
1. Analyze the compiler error messages provided by the Codesys IDE and locate the actual erroneous ST code segment.
2. Explain why the error occurred using IEC 61131-3 rules and Codesys-specific language semantics.
3. Provide detailed and actionable corrective suggestions for each identified issue.
4. Output a patch using the following required format.

IMPORTANT:
- Assume compilation is performed within the Codesys environment, targeting platforms such as Beckhoff, WAGO, or Schneider Electric PLCs.
- <code_segment> must be a verbatim copy of the original ST code, including indentation and comments.
- <patch> must be a direct replacement for the code segment and must be syntactically valid for Structured Text in Codesys.
- Clearly identify violated syntax rules, common function block misuse, or incorrect data typing.
- Consider that some compiler errors may cascade—reason about task execution flow and variable scope to identify the root issue.
- Avoid altering the original control logic or behavior unless absolutely necessary for correctness.
- If you find a "BEGIN" between the variable declarations and the code logic section, remove it.
- Do not use variables that are not declared in the declaration section.

OUTPUT FORMAT:
```plaintext
- Fix suggestion 1: [Clear and actionable error fix suggestion]
- Fix suggestion k: [Clear and actionable error fix suggestion]
(1)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
(n)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
```

--Appendix--
ST Library Functions:
{api_details}
ST Programming Guidelines:
{programming_guidance}
"""

verifier_instance_prompt = """
Input structured in XML format:
<!-- Code with errors. -->
<STCode>
{st_code}
</STCode>
<!-- Errors. -->
<Errors>
{static_analysis_results}
</Errors>
"""

programming_guidance = "NO PROGRAMMING GUIDANCE"


def extract_content(response) -> str:
    """
    提取响应内容中的st代码。
    支持多种响应格式。
    """
    if hasattr(response, 'choices'):
        choice = response.choices[0]
        if hasattr(choice, 'message') and hasattr(choice.message, 'content'):
            st_code = choice.message.content
        else:
            st_code = choice['message']['content']
    elif hasattr(response, 'content'):
        st_code = response.content[0].text if isinstance(response.content, list) else response.content
    elif isinstance(response, str):
        st_code = response
    else:
        st_code = str(response)
    return st_code


def parse_patch(text: str) -> List[tuple]:
    """
    解析给定文本中的代码段和补丁。
    
    返回:
    - List[tuple] - 一个包含多个元组的列表，每个元组包含两个字符串：
      1. buggy 代码（修复前的代码）。
      2. patch（修复该问题的补丁）。
    """
    # 编译一个正则表达式模式，用于匹配<code_segment>和<patch>标签之间的内容。
    pattern = re.compile(
        r'<code_segment>(.*?)</code_segment>\s*<patch>(.*?)</patch>', 
        re.DOTALL
    )
    
    # 使用编译的正则表达式查找所有匹配项。
    matches = pattern.findall(text)
    results = []
    for buggy, patch in matches:
        # 将匹配到的buggy代码和patch去除前后空格后，作为元组添加到结果列表中。
        results.append((buggy.strip(), patch.strip()))
    
    # 返回处理后的结果列表。
    return results


def call_llm_for_fix(messages: List[dict], llm_client=None, use_openai: bool = False, 
                     openai_api_key: Optional[str] = None, model: str = "gpt-4o",
                     base_url: Optional[str] = None) -> str:
    """
    调用大模型进行代码修复。
    
    参数:
    - messages: 消息列表，格式为 [{"role": "system", "content": "..."}, ...]
    - llm_client: 自定义的LLM客户端对象，如果有则使用它
    - use_openai: 是否使用openai库（需要安装openai包）
    - openai_api_key: API密钥
    - model: 使用的模型名称
    - base_url: API的基础URL（用于智增增等API中转站），如果为None则使用OpenAI默认URL
    
    返回:
    - str: 模型返回的修复建议文本
    """
    if llm_client is not None:
        # 使用自定义客户端
        if hasattr(llm_client, 'call'):
            response = llm_client.call(messages=messages)
            return extract_content(response)
        elif hasattr(llm_client, '__call__'):
            response = llm_client(messages)
            return extract_content(response)
        else:
            raise ValueError("自定义LLM客户端必须实现call方法或可调用")
    
    if use_openai:
        try:
            import openai
            if base_url:
                # 使用自定义base_url（如智增增API）
                client = openai.OpenAI(
                    api_key=openai_api_key,
                    base_url=base_url
                )
            elif openai_api_key:
                # 使用OpenAI官方API
                client = openai.OpenAI(api_key=openai_api_key)
            else:
                # 尝试从环境变量获取
                client = openai.OpenAI()
            
            response = client.chat.completions.create(
                model=model,
                messages=messages
            )
            return extract_content(response)
        except ImportError:
            raise ImportError("需要安装openai库: pip install openai")
        except Exception as e:
            raise Exception(f"调用API失败: {e}")
    
    # 如果没有提供客户端，返回提示信息
    raise ValueError("请提供llm_client参数或设置use_openai=True并配置openai_api_key")


def auto_fix_st_code(
    st_file_path: str,
    block_name: Optional[str] = None,
    max_verify_count: int = 3,
    ip_port: Optional[str] = None,
    llm_client=None,
    use_openai: bool = False,
    openai_api_key: Optional[str] = None,
    model: str = "gpt-4o",
    base_url: Optional[str] = None,
    api_details: str = "",
    programming_guidance_text: Optional[str] = None
) -> tuple:
    """
    自动修复ST代码的主流程。
    
    参数:
    - st_file_path: test.st文件的路径
    - block_name: 代码块名称，如果为None则从文件内容中提取
    - max_verify_count: 最大验证/修复次数
    - ip_port: CODESYS API地址，如果为None则使用默认值
    - llm_client: 自定义的LLM客户端对象
    - use_openai: 是否使用openai库
    - openai_api_key: API密钥
    - model: 使用的模型名称
    - base_url: API的基础URL（用于智增增等API中转站），如果为None则使用OpenAI默认URL
    - api_details: ST库函数详情（用于system prompt）
    - programming_guidance_text: 编程指导文本（用于system prompt）
    
    返回:
    - tuple: (修复后的代码, 是否成功, 尝试次数)
    """
    # 读取test.st文件
    if not os.path.exists(st_file_path):
        raise FileNotFoundError(f"文件不存在: {st_file_path}")
    
    with open(st_file_path, 'r', encoding='utf-8') as f:
        st_code = f.read()
    
    # 如果没有指定block_name，尝试从代码中提取
    if block_name is None:
        # 尝试提取FUNCTION_BLOCK或PROGRAM名称
        match = re.search(r'(?:FUNCTION_BLOCK|PROGRAM|FUNCTION)\s+(\w+)', st_code, re.IGNORECASE)
        if match:
            block_name = match.group(1)
        else:
            block_name = "TestBlock"
    
    # 使用默认IP地址
    if ip_port is None:
        ip_port = CODESYS_API_URL
    
    # 初始化编译器实例
    compiler = CodesysCompiler()
    start_time = time.time()
    
    # 构建验证器的系统提示信息
    pg_text = programming_guidance_text if programming_guidance_text is not None else programming_guidance
    verifier_system_prompt_with_data = verifier_system_prompt.format(
        api_details=api_details,                                                       #?????
        programming_guidance=pg_text
    )
    
    verifier_messages = [{"role": "system", "content": verifier_system_prompt_with_data}]
    
    #真正检查之前先静态检查一下



    # 尝试验证和修复代码，直到成功或达到最大尝试次数
    verify_count = 0
    while verify_count < max_verify_count:
        verify_count += 1
        print(f"\n{'='*60}")
        print(f"第 {verify_count} 次验证尝试")
        print(f"{'='*60}")
        
        # 调用语法检查
        check_result = compiler.syntax_check(block_name, st_code, ip_port)     #调用codesys_debug.syntax_check
        no_error = check_result.success
        
        elapsed_time = time.time() - start_time
        print(f"编译耗时: {elapsed_time:.2f} 秒")
        
        if no_error:
            print(f"{block_name} SUCCESS!")
            # print(f"\n最终代码:\n{st_code}")
            return (st_code, True, verify_count)
        else:
            error_list = []
            
            # 首选 Declaration Section 的错误，因为会引发级联错误
            for error in check_result.errors:
                if error.error_type == "Declaration Section Error":
                    print(f"Declaration Error >>> {str(error)}")
                    error_list.append(error.to_dict())
            
            # 如果没有 Declaration Section 的错误，则检查 Implementation Section 的错误
            if not error_list:
                for error in check_result.errors:
                    if error.error_type == "Implementation Section Error":
                        print(f'Implementation Error >>>> {str(error)}')
                        error_list.append(error.to_dict())
            
            # 记录所有错误信息
            all_errors = [error.to_dict() for error in check_result.errors]
            error_log = '\n'.join([str(err) for err in error_list])
            
            print(f'\n{block_name} 发现错误，开始调用大模型修复...')
            print(f"错误总数: {len(check_result.errors)}")
            
            # 构建用户提示
            verifier_instance_prompt_with_data = verifier_instance_prompt.format(
                static_analysis_results=error_log,
                st_code=st_code
            )
            verifier_messages.append({"role": "user", "content": verifier_instance_prompt_with_data})
            
            # 使用AI模型生成修复补丁
            try:
                verify_result = call_llm_for_fix(
                    verifier_messages,
                    llm_client=llm_client,
                    use_openai=use_openai,
                    openai_api_key=openai_api_key,
                    model=model,
                    base_url=base_url
                )
                
                verifier_messages.append({"role": "assistant", "content": verify_result})
                print(f"\n模型返回的修复建议:\n{verify_result}\n")
                
                # 解析补丁
                segments_and_patches = parse_patch(verify_result)
                
                if not segments_and_patches:
                    print("警告: 未能从模型响应中解析出补丁，跳过本次修复")
                    continue
                
                # 应用修复补丁到代码中
                print(f"应用 {len(segments_and_patches)} 个补丁...")
                for buggy, patch in segments_and_patches:
                    if buggy in st_code:
                        st_code = st_code.replace(buggy, patch)
                        print(f"  ✓ 已应用补丁")
                    else:
                        print(f"  ✗ 未找到匹配的代码段，跳过此补丁")
                        print(f"    查找的代码段:\n {buggy[:50]}...")
                
            except Exception as e:
                print(f"调用大模型失败: {e}")
                print("跳过本次修复尝试")
                continue
            
            print(f"{block_name} 修复完成 ({verify_count}/{max_verify_count}) - 执行时间: {(time.time() - start_time):.6f} 秒")
    
    # 达到最大尝试次数仍未成功
    print(f"\n{'='*60}")
    print(f"达到最大尝试次数 ({max_verify_count})，停止修复")
    print(f"{'='*60}")
    return (st_code, False, verify_count)


if __name__ == "__main__":
    # 测试代码
    test_st_path = os.path.join(os.path.dirname(__file__), "test.st")
    
    print("=" * 60)
    print("开始自动修复ST代码流程")
    print("=" * 60)
    print(f"读取文件: {test_st_path}")
    
    # 智增增API配置 - 从环境变量读取
    API_KEY = ZHIZENGZENG_API_KEY
    BASE_URL = ZHIZENGZENG_BASE_URL
    
    # 检查API配置
    if not API_KEY or API_KEY == "":
        print("错误: 未配置API密钥！")
        print("请在CMD中设置环境变量:")
        print("  set ZHIZENGZENG_API_KEY=你的API密钥")
        print("  set ZHIZENGZENG_BASE_URL=https://api.zhizengzeng.com/v1")
        exit(1)
    
    print(f"使用API地址: {BASE_URL}")
    print(f"使用模型: gpt-4o")
    
    # 使用智增增API进行自动修复
    fixed_code, success, count = auto_fix_st_code(
        test_st_path,
        max_verify_count=3,
        use_openai=True,
        openai_api_key=API_KEY,
        base_url=BASE_URL,
        model="gpt-4o"  # 可以根据智增增支持的模型调整
    )
    
    if success:
        print(f"\n✓ 修复成功！共尝试 {count} 次")
        # 可选：保存修复后的代码
        output_path = os.path.join(os.path.dirname(__file__), "test_fixed.st")
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(fixed_code)
        print(f"修复后的代码已保存到: {output_path}")
    else:
        print(f"\n✗ 修复失败，已达到最大尝试次数 ({count})")
        # print("最终代码:")
        # print(fixed_code)
    
    # 方式1: 使用OpenAI官方API（需要设置环境变量OPENAI_API_KEY或传入openai_api_key参数）
    # fixed_code, success, count = auto_fix_st_code(
    #     test_st_path,
    #     max_verify_count=5,
    #     use_openai=True,
    #     openai_api_key=None,  # 如果为None，会尝试从环境变量获取
    #     model="gpt-4"
    # )
    
    # 方式2: 使用自定义LLM客户端
    # class MyLLMClient:
    #     def call(self, messages):
    #         # 实现你的LLM调用逻辑
    #         return "模型响应"
    # 
    # client = MyLLMClient()
    # fixed_code, success, count = auto_fix_st_code(
    #     test_st_path,
    #     max_verify_count=5,
    #     llm_client=client
    # )
    
    # 方式3: 仅编译检查，不调用大模型（用于测试）
    # print("\n注意: 当前仅进行编译检查，未调用大模型修复")
    # print("要启用自动修复，请:")
    # print("  1. 设置 use_openai=True 并配置 openai_api_key 和 base_url")
    # print("  2. 或提供自定义的 llm_client 对象")
    # print("\n开始编译检查...")
    # 
    # # 仅进行编译检查
    # compiler = CodesysCompiler()
    # with open(test_st_path, 'r', encoding='utf-8') as f:
    #     st_code = f.read()
    # 
    # # 提取block名称
    # match = re.search(r'(?:FUNCTION_BLOCK|PROGRAM|FUNCTION)\s+(\w+)', st_code, re.IGNORECASE)
    # block_name = match.group(1) if match else "TestBlock"
    # 
    # check_result = compiler.syntax_check(block_name, st_code, CODESYS_API_URL)
    # 
    # print(f"\n编译结果: {'成功' if check_result.success else '失败'}")
    # if check_result.errors:
    #     print(f"错误数量: {len(check_result.errors)}")
    #     for i, error in enumerate(check_result.errors, 1):
    #         print(f"\n错误 {i}:")
    #         print(f"  类型: {error.error_type}")
    #         print(f"  描述: {error.error_desc}")
    #         if error.code_window:
    #             print(f"  代码窗口:\n{error.code_window}")

