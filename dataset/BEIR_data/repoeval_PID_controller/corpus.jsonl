{"_id": "PID_controller_Globals_GVL_Input.st_0-15", "title": "PID_controller-Globals\\GVL_Input.st", "text": "VAR_GLOBAL\n\tKnapp1: BOOL; // Knapp på våning 1\n\tKnapp2: BOOL; // \n\tKnapp3: BOOL;\n\tKnapp4: BOOL;\n\tVaning1 :BOOL;\n\tVaning2 :BOOL;\n\tVaning3 :BOOL;\n\tVaning4 :BOOL;\n\tManuell :BOOL;\n\tAuto :BOOL;\n\tUpp :BOOL;\n\tNer  :BOOL;\n\tService_reset :BOOL;\nEND_VAR\n", "metadata": [{"fpath_tuple": ["PID_controller", "Globals\\GVL_Input.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 15, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Globals_GVL_Memory.st_0-2", "title": "PID_controller-Globals\\GVL_Memory.st", "text": "VAR_GLOBAL\nEND_VAR", "metadata": [{"fpath_tuple": ["PID_controller", "Globals\\GVL_Memory.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 2, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Globals_GVL_Output.st_0-11", "title": "PID_controller-Globals\\GVL_Output.st", "text": "VAR_GLOBAL\n\tLampa1 :BOOL;\n\tLampa2 :BOOL;\n\tLampa3 :BOOL;\n\tLampa4 :BOOL;\n\tHissUpp :BOOL;\n\tHissNer :BOOL;\n\tHissDorr :BOOL;\n\tLampaAuto :BOOL;\n\t\nEND_VAR\n", "metadata": [{"fpath_tuple": ["PID_controller", "Globals\\GVL_Output.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 11, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger.st_0-25", "title": "PID_controller-Models\\HeatExchanger.st", "text": "// AJ Jaworowski 2015-02-22\n// Following the recipe by  Peter Nachtwey\n// http://www.controlguru.com/wp/p80.html\nFUNCTION_BLOCK HeatExchanger\nVAR_INPUT\n\tKp: REAL; //System gain\n\tTp: REAL; //Process time\n\tCO: REAL; //Output from controller\n\tDead_t: REAL; //The time before the system responds to the disturbance\n\tC: REAL; //Initial steady state value\n\tSample_time: TIME;\nEND_VAR\nVAR_OUTPUT\n\tPV: REAL; //Process value at t1\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV:REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger.st_0-30", "title": "PID_controller-Models\\HeatExchanger.st", "text": "// AJ Jaworowski 2015-02-22\n// Following the recipe by  Peter Nachtwey\n// http://www.controlguru.com/wp/p80.html\nFUNCTION_BLOCK HeatExchanger\nVAR_INPUT\n\tKp: REAL; //System gain\n\tTp: REAL; //Process time\n\tCO: REAL; //Output from controller\n\tDead_t: REAL; //The time before the system responds to the disturbance\n\tC: REAL; //Initial steady state value\n\tSample_time: TIME;\nEND_VAR\nVAR_OUTPUT\n\tPV: REAL; //Process value at t1\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV:REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger.st_0-35", "title": "PID_controller-Models\\HeatExchanger.st", "text": "// AJ Jaworowski 2015-02-22\n// Following the recipe by  Peter Nachtwey\n// http://www.controlguru.com/wp/p80.html\nFUNCTION_BLOCK HeatExchanger\nVAR_INPUT\n\tKp: REAL; //System gain\n\tTp: REAL; //Process time\n\tCO: REAL; //Output from controller\n\tDead_t: REAL; //The time before the system responds to the disturbance\n\tC: REAL; //Initial steady state value\n\tSample_time: TIME;\nEND_VAR\nVAR_OUTPUT\n\tPV: REAL; //Process value at t1\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV:REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\tA := EXP(-delta_t/Tp);\n\tB := 1 - A;\n\tC := 2;\n\t\n\t//PV := A * lastPV + B * Kp * CO + C;\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger.st_0-40", "title": "PID_controller-Models\\HeatExchanger.st", "text": "// AJ Jaworowski 2015-02-22\n// Following the recipe by  Peter Nachtwey\n// http://www.controlguru.com/wp/p80.html\nFUNCTION_BLOCK HeatExchanger\nVAR_INPUT\n\tKp: REAL; //System gain\n\tTp: REAL; //Process time\n\tCO: REAL; //Output from controller\n\tDead_t: REAL; //The time before the system responds to the disturbance\n\tC: REAL; //Initial steady state value\n\tSample_time: TIME;\nEND_VAR\nVAR_OUTPUT\n\tPV: REAL; //Process value at t1\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV:REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\tA := EXP(-delta_t/Tp);\n\tB := 1 - A;\n\tC := 2;\n\t\n\t//PV := A * lastPV + B * Kp * CO + C;\n\tPV := 0.987 * lastPV - 0.00679 * CO + C;\n\tlastPV := PV;\n\n\tlastTime := now;\nEND_IF ", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 0, "end_line_no": 40, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-25", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-30", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-35", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\t\n\t//First calculate net heat\n\t//Heat_In is our heat source\n\t//Second term is heat flow depending on temperature difference\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-40", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\t\n\t//First calculate net heat\n\t//Heat_In is our heat source\n\t//Second term is heat flow depending on temperature difference\n\t//Obs: At start, set lastTime to start temp Temp_In\n\tIF lastTime = T#0S THEN\n\t\tlastTemp := Temp_In;\n\tEND_IF\n\theat_flow := Heat_In - U * (lastTemp - Temp_Out);\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 0, "end_line_no": 40, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-45", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\t\n\t//First calculate net heat\n\t//Heat_In is our heat source\n\t//Second term is heat flow depending on temperature difference\n\t//Obs: At start, set lastTime to start temp Temp_In\n\tIF lastTime = T#0S THEN\n\t\tlastTemp := Temp_In;\n\tEND_IF\n\theat_flow := Heat_In - U * (lastTemp - Temp_Out);\n\t\n\t//Second: calculate temperature change due to heat_flow\n\tTemp := lastTemp + heat_flow * delta_t / TC;\n\t\n\t//Update variables for next iteration\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_HeatExchanger2.st_0-48", "title": "PID_controller-Models\\HeatExchanger2.st", "text": "// AJ Jaworowski 2015-02-23\n// Following the presentation on\n// http://openenergymonitor.org/emon/node/2999\nFUNCTION_BLOCK HeatExchanger2\nVAR_INPUT\n\tHeat_In:\t\tREAL;\t\t//In principle a radiator in the room [W]\n\tU:\t\t\t\tREAL;\t\t//Thermal conductance [W/K]\n\tTC:\t\t\t\tREAL;\t\t//Thermal capacity [J/K], commonly cv, specific heat capacity [J/kgK]\n\t\t\t\t\t\t\t\t//we use a smaller value than in reality, so that we can see changes\n\t\t\t\t\t\t\t\t//during a life-time...\n\tTemp_In:\t\tREAL;\t\t//Start temperature in the room [K]\n\tTemp_Out:\t\tREAL;\t\t//Outside temperature [K] \n\tSample_time:\tTIME;\nEND_VAR\nVAR_OUTPUT\n\tTemp:\t\t\tREAL;\t\t//The resulting room temperature\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time)/millis;\n\t\n\t//First calculate net heat\n\t//Heat_In is our heat source\n\t//Second term is heat flow depending on temperature difference\n\t//Obs: At start, set lastTime to start temp Temp_In\n\tIF lastTime = T#0S THEN\n\t\tlastTemp := Temp_In;\n\tEND_IF\n\theat_flow := Heat_In - U * (lastTemp - Temp_Out);\n\t\n\t//Second: calculate temperature change due to heat_flow\n\tTemp := lastTemp + heat_flow * delta_t / TC;\n\t\n\t//Update variables for next iteration\n\tlastTemp := Temp;\n\tlastTime := now;\nEND_IF;", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\HeatExchanger2.st"], "repo": "PID_controller", "line_no": 25, "start_line_no": 0, "end_line_no": 48, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_Tank.st_0-25", "title": "PID_controller-Models\\Tank.st", "text": "//A.J. Jaworowski 2015-02-20\n//Simulering av en tank med RedBull\nFUNCTION_BLOCK Tank\nVAR_INPUT\n\tProcess_In: REAL;  //Flöde in per sekund, testa vad som händer on du matar in 100\n\t\t\t\t\t   //Därefter ska regulatorns OUT in i denna ingång.\n\tProcess_Out: REAL; //Flöde ut per sekund, typ 90\n\t\t\t\t\t   //Effekten blir att tanken fylls med 10 per sekund\n\t\t\t\t\t   //Full efter ca 1 minut - testa\n\tSampleTime: TIME;  //Uppdateringstid, typ 100ms\n\tLower_limit: REAL; //Tankens lägsta nivå, typ 0\n\tUpper_limit: REAL; //Tankens max nivå, kanske 500\nEND_VAR\nVAR_OUTPUT\n\tLevel: REAL; //Nivån i tanken\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tproc_sum_in: REAL := 0;\n\tproc_sum_out: REAL := 0;\n\ttemp: REAL;\n\tmillis: UINT := 1000;\n\tproc_out: REAL;\nEND_VAR\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\Tank.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_Tank.st_0-30", "title": "PID_controller-Models\\Tank.st", "text": "//A.J. Jaworowski 2015-02-20\n//Simulering av en tank med RedBull\nFUNCTION_BLOCK Tank\nVAR_INPUT\n\tProcess_In: REAL;  //Flöde in per sekund, testa vad som händer on du matar in 100\n\t\t\t\t\t   //Därefter ska regulatorns OUT in i denna ingång.\n\tProcess_Out: REAL; //Flöde ut per sekund, typ 90\n\t\t\t\t\t   //Effekten blir att tanken fylls med 10 per sekund\n\t\t\t\t\t   //Full efter ca 1 minut - testa\n\tSampleTime: TIME;  //Uppdateringstid, typ 100ms\n\tLower_limit: REAL; //Tankens lägsta nivå, typ 0\n\tUpper_limit: REAL; //Tankens max nivå, kanske 500\nEND_VAR\nVAR_OUTPUT\n\tLevel: REAL; //Nivån i tanken\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tproc_sum_in: REAL := 0;\n\tproc_sum_out: REAL := 0;\n\ttemp: REAL;\n\tmillis: UINT := 1000;\n\tproc_out: REAL;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\tLevel := Level +  TIME_TO_REAL(SampleTime)/millis * (Process_In - Process_Out);\n\tIF Level < Lower_limit THEN\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\Tank.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_Tank.st_0-35", "title": "PID_controller-Models\\Tank.st", "text": "//A.J. Jaworowski 2015-02-20\n//Simulering av en tank med RedBull\nFUNCTION_BLOCK Tank\nVAR_INPUT\n\tProcess_In: REAL;  //Flöde in per sekund, testa vad som händer on du matar in 100\n\t\t\t\t\t   //Därefter ska regulatorns OUT in i denna ingång.\n\tProcess_Out: REAL; //Flöde ut per sekund, typ 90\n\t\t\t\t\t   //Effekten blir att tanken fylls med 10 per sekund\n\t\t\t\t\t   //Full efter ca 1 minut - testa\n\tSampleTime: TIME;  //Uppdateringstid, typ 100ms\n\tLower_limit: REAL; //Tankens lägsta nivå, typ 0\n\tUpper_limit: REAL; //Tankens max nivå, kanske 500\nEND_VAR\nVAR_OUTPUT\n\tLevel: REAL; //Nivån i tanken\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tproc_sum_in: REAL := 0;\n\tproc_sum_out: REAL := 0;\n\ttemp: REAL;\n\tmillis: UINT := 1000;\n\tproc_out: REAL;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\tLevel := Level +  TIME_TO_REAL(SampleTime)/millis * (Process_In - Process_Out);\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\tlastTime := now;\n", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\Tank.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Models_Tank.st_0-36", "title": "PID_controller-Models\\Tank.st", "text": "//A.J. Jaworowski 2015-02-20\n//Simulering av en tank med RedBull\nFUNCTION_BLOCK Tank\nVAR_INPUT\n\tProcess_In: REAL;  //Flöde in per sekund, testa vad som händer on du matar in 100\n\t\t\t\t\t   //Därefter ska regulatorns OUT in i denna ingång.\n\tProcess_Out: REAL; //Flöde ut per sekund, typ 90\n\t\t\t\t\t   //Effekten blir att tanken fylls med 10 per sekund\n\t\t\t\t\t   //Full efter ca 1 minut - testa\n\tSampleTime: TIME;  //Uppdateringstid, typ 100ms\n\tLower_limit: REAL; //Tankens lägsta nivå, typ 0\n\tUpper_limit: REAL; //Tankens max nivå, kanske 500\nEND_VAR\nVAR_OUTPUT\n\tLevel: REAL; //Nivån i tanken\nEND_VAR\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tproc_sum_in: REAL := 0;\n\tproc_sum_out: REAL := 0;\n\ttemp: REAL;\n\tmillis: UINT := 1000;\n\tproc_out: REAL;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\tLevel := Level +  TIME_TO_REAL(SampleTime)/millis * (Process_In - Process_Out);\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\tlastTime := now;\nEND_IF;", "metadata": [{"fpath_tuple": ["PID_controller", "Models\\Tank.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 0, "end_line_no": 36, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-25", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-30", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-35", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-40", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 0, "end_line_no": 40, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-45", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 20, "start_line_no": 0, "end_line_no": 45, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_0-50", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\n//* A simple PID controller for Codesys.\n//* by Alexander Jaworowski\n//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library\n//* https://github.com/alexjaw/PID_controller\n//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 25, "start_line_no": 0, "end_line_no": 50, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_5-55", "title": "PID_controller-PID\\PID_controller.st", "text": "//* This Library is licensed under a MIT License\n//\n// 2015-02-22\tBug fix in the calculation of CO_I.\n//\t\t\t\tAdded derivative term (d(err)/dt = -d(PV)/dt, i.e.\n//\t\t\t\tderivative on measurements\n//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 5, "end_line_no": 55, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_10-60", "title": "PID_controller-PID\\PID_controller.st", "text": "//***************************************************************\nFUNCTION_BLOCK PID_controller\nVAR_INPUT\n\tSP : REAL;\n\tPV : REAL;\n\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 10, "end_line_no": 60, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_15-65", "title": "PID_controller-PID\\PID_controller.st", "text": "\tKc : REAL;\n\tTi : REAL;\n\tTd : REAL;\n\tSampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]\n\tLowerLimit: REAL;\n\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n\t//Observe that d(err)/dt = d(SP)/dt - d(PV)/dt\n\t//If SP constant,\n\t//d(err)/dt = - d(PV)/dt\n\t//Good: no output spikes\n\t//Bad: some processes need more aggressive tuning\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 15, "end_line_no": 65, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_20-70", "title": "PID_controller-PID\\PID_controller.st", "text": "\tUpperLimit: REAL;\nEND_VAR\nVAR_OUTPUT\n\tCO: REAL; //Controller Output\n\tCO_P: REAL; //Prportional term\n\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n\t//Observe that d(err)/dt = d(SP)/dt - d(PV)/dt\n\t//If SP constant,\n\t//d(err)/dt = - d(PV)/dt\n\t//Good: no output spikes\n\t//Bad: some processes need more aggressive tuning\n\tIF delta_t <> 0 THEN\n\t\tCO_D := Td * (PV - lastPV)/delta_t;\n\tEND_IF;\n\t\n\t//A different approch would be with a tunable filter\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 20, "start_line_no": 20, "end_line_no": 70, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_25-75", "title": "PID_controller-PID\\PID_controller.st", "text": "\tCO_I: REAL; //Integral term\n\tCO_D: REAL; //Derivative term\nEND_VAR\nVAR CONSTANT\n\tmillis: UINT := 1000;\nEND_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n\t//Observe that d(err)/dt = d(SP)/dt - d(PV)/dt\n\t//If SP constant,\n\t//d(err)/dt = - d(PV)/dt\n\t//Good: no output spikes\n\t//Bad: some processes need more aggressive tuning\n\tIF delta_t <> 0 THEN\n\t\tCO_D := Td * (PV - lastPV)/delta_t;\n\tEND_IF;\n\t\n\t//A different approch would be with a tunable filter\n\t\n\tCO := CO_P + CO_I + CO_D;\n\t//Add wind-up for CO\n\tIF CO < LowerLimit THEN\n\t\tCO := LowerLimit;\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 25, "start_line_no": 25, "end_line_no": 75, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_30-80", "title": "PID_controller-PID\\PID_controller.st", "text": "END_VAR\nVAR\n\tnow: TIME := T#0S;\n\tlastTime: TIME := T#0S;\n\terr: REAL := 0; //Process error\n\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n\t//Observe that d(err)/dt = d(SP)/dt - d(PV)/dt\n\t//If SP constant,\n\t//d(err)/dt = - d(PV)/dt\n\t//Good: no output spikes\n\t//Bad: some processes need more aggressive tuning\n\tIF delta_t <> 0 THEN\n\t\tCO_D := Td * (PV - lastPV)/delta_t;\n\tEND_IF;\n\t\n\t//A different approch would be with a tunable filter\n\t\n\tCO := CO_P + CO_I + CO_D;\n\t//Add wind-up for CO\n\tIF CO < LowerLimit THEN\n\t\tCO := LowerLimit;\n\tELSIF CO > UpperLimit THEN\n\t\tCO := UpperLimit;\n\tEND_IF;\n\t\n\tlastTime := now;\n", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 30, "start_line_no": 30, "end_line_no": 80, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_PID_PID_controller.st_35-82", "title": "PID_controller-PID\\PID_controller.st", "text": "\tlastCO_P: REAL := 0;  //Used for calculation of the derivative term\n\tdelta_t: REAL;\n\tlastPV: REAL := 0;\nEND_VAR\n\n//Check parameters\n//Ti division by zero\nIF Ti = 0 THEN\n\tTi := 1;\nEND_IF\n\n//Update PID parameters every sampleTime\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\terr := SP - PV;\n\tdelta_t := TIME_TO_REAL(SampleTime)/millis;\n\tCO_P := Kc * err;\n\tCO_I := CO_I + 1/Ti * CO_P * delta_t;\n\t//Add wind-up for CO_I\n\tIF CO_I < LowerLimit THEN\n\t\tCO_I := LowerLimit;\n\tELSIF CO_I > UpperLimit THEN\n\t\tCO_I := UpperLimit;\n\tEND_IF;\n\t\n\t//Observe that d(err)/dt = d(SP)/dt - d(PV)/dt\n\t//If SP constant,\n\t//d(err)/dt = - d(PV)/dt\n\t//Good: no output spikes\n\t//Bad: some processes need more aggressive tuning\n\tIF delta_t <> 0 THEN\n\t\tCO_D := Td * (PV - lastPV)/delta_t;\n\tEND_IF;\n\t\n\t//A different approch would be with a tunable filter\n\t\n\tCO := CO_P + CO_I + CO_D;\n\t//Add wind-up for CO\n\tIF CO < LowerLimit THEN\n\t\tCO := LowerLimit;\n\tELSIF CO > UpperLimit THEN\n\t\tCO := UpperLimit;\n\tEND_IF;\n\t\n\tlastTime := now;\n\tlastPV := PV;\nEND_IF;", "metadata": [{"fpath_tuple": ["PID_controller", "PID\\PID_controller.st"], "repo": "PID_controller", "line_no": 35, "start_line_no": 35, "end_line_no": 82, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID.st_0-25", "title": "PID_controller-Progs\\Test_PID.st", "text": "PROGRAM Test_PID\nVAR\n\tPID_0: PID_controller;\n\tRedBull: Tank;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 250;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,                // 设定值：目标液位250\n    PV := RedBull.Level,              // 过程值：储罐当前液位（反馈）\n    Kc := 2,                  // 比例增益2.0\n    Ti := 15,                  // 积分时间15.0\n    Td := 1,                  // 微分时间1.0\n    SampleTime := T#100ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 150,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID.st_0-30", "title": "PID_controller-Progs\\Test_PID.st", "text": "PROGRAM Test_PID\nVAR\n\tPID_0: PID_controller;\n\tRedBull: Tank;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 250;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,                // 设定值：目标液位250\n    PV := RedBull.Level,              // 过程值：储罐当前液位（反馈）\n    Kc := 2,                  // 比例增益2.0\n    Ti := 15,                  // 积分时间15.0\n    Td := 1,                  // 微分时间1.0\n    SampleTime := T#100ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 150,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n\n// 2. 调用储罐功能块\nRedBull(\n    Process_In := PID_0.CO,          // 输入流量：PID的输出CO\n    Process_Out := Process_out,    // 输出流量：100（外部定义）\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID.st_0-35", "title": "PID_controller-Progs\\Test_PID.st", "text": "PROGRAM Test_PID\nVAR\n\tPID_0: PID_controller;\n\tRedBull: Tank;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 250;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,                // 设定值：目标液位250\n    PV := RedBull.Level,              // 过程值：储罐当前液位（反馈）\n    Kc := 2,                  // 比例增益2.0\n    Ti := 15,                  // 积分时间15.0\n    Td := 1,                  // 微分时间1.0\n    SampleTime := T#100ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 150,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n\n// 2. 调用储罐功能块\nRedBull(\n    Process_In := PID_0.CO,          // 输入流量：PID的输出CO\n    Process_Out := Process_out,    // 输出流量：100（外部定义）\n    Sample_time := T#250ms,// 采样时间250ms\n    Lower_limit := 0,// 液位下限0\n    Upper_limit := 500,// 液位上限500\n    Level =>             // 输出当前液位：反馈给PID的PV\n);", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heat2.st_0-25", "title": "PID_controller-Progs\\Test_PID_Heat2.st", "text": "PROGRAM Test_PID_Heat2\nVAR\n\tPID_controller_0: PID_controller;\n\tHeatExchanger2_0: HeatExchanger2;\n\tSP: REAL := 300;\n\tTemp_out: REAL := 270;\nEND_VAR\n\nPID_controller_0(\n    SP := SP,                // 设定值：目标液位250\n    PV := HeatExchanger2_0.Temp,              // 过程值：储罐当前液位（反馈）\n    Kc := 50,                  // 比例增益2.0\n    Ti := 5,                  // 积分时间15.0\n    Td := 0,                  // 微分时间1.0\n    SampleTime := T#250ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 6000,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n\n// 2. 调用储罐功能块\nHeatExchanger2_0(\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heat2.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heat2.st_0-30", "title": "PID_controller-Progs\\Test_PID_Heat2.st", "text": "PROGRAM Test_PID_Heat2\nVAR\n\tPID_controller_0: PID_controller;\n\tHeatExchanger2_0: HeatExchanger2;\n\tSP: REAL := 300;\n\tTemp_out: REAL := 270;\nEND_VAR\n\nPID_controller_0(\n    SP := SP,                // 设定值：目标液位250\n    PV := HeatExchanger2_0.Temp,              // 过程值：储罐当前液位（反馈）\n    Kc := 50,                  // 比例增益2.0\n    Ti := 5,                  // 积分时间15.0\n    Td := 0,                  // 微分时间1.0\n    SampleTime := T#250ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 6000,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n\n// 2. 调用储罐功能块\nHeatExchanger2_0(\n    Heat_In := PID_controller_0.CO,\n    U := 100,   \n    TC := 2500,\n    Temp_In := 270,\n    Temp_Out := Temp_Out;\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heat2.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heat2.st_0-33", "title": "PID_controller-Progs\\Test_PID_Heat2.st", "text": "PROGRAM Test_PID_Heat2\nVAR\n\tPID_controller_0: PID_controller;\n\tHeatExchanger2_0: HeatExchanger2;\n\tSP: REAL := 300;\n\tTemp_out: REAL := 270;\nEND_VAR\n\nPID_controller_0(\n    SP := SP,                // 设定值：目标液位250\n    PV := HeatExchanger2_0.Temp,              // 过程值：储罐当前液位（反馈）\n    Kc := 50,                  // 比例增益2.0\n    Ti := 5,                  // 积分时间15.0\n    Td := 0,                  // 微分时间1.0\n    SampleTime := T#250ms,  // 采样时间100ms\n    LowerLimit := 0,  // 输出下限0\n    UpperLimit := 6000,  // 输出上限150\n    CO => ,                  // PID输出：控制储罐的输入流量\n    CO_P => ,                      // 比例部分输出（未使用可留空）\n    CO_I => ,                      // 积分部分输出（未使用可留空）\n    CO_D =>                        // 微分部分输出（未使用可留空）\n);\n\n// 2. 调用储罐功能块\nHeatExchanger2_0(\n    Heat_In := PID_controller_0.CO,\n    U := 100,   \n    TC := 2500,\n    Temp_In := 270,\n    Temp_Out := Temp_Out;\n    Sample_time := T#100ms,\n    Temp =>            \n);", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heat2.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 33, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heatx.st_0-25", "title": "PID_controller-Progs\\Test_PID_Heatx.st", "text": "PROGRAM Test_PID_Heatx\nVAR\n\tPID_0: PID_controller;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 20;\n\tA_room_with_a_view: HeatExchanger;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,\n    PV := A_room_with_a_view.PV,\n    Kc := 5.0,\n    Ti := 10.0,\n    Td := 1.0,\n    SampleTime := T#2000ms,\n    LowerLimit := 0,\n    UpperLimit := 150,\n    CO => ,  // 若不需要单独使用 CO 等输出，可留空，或根据需求定义变量接收\n    CO_P => ,\n    CO_I => ,\n    CO_D => \n);\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heatx.st"], "repo": "PID_controller", "line_no": 0, "start_line_no": 0, "end_line_no": 25, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heatx.st_0-30", "title": "PID_controller-Progs\\Test_PID_Heatx.st", "text": "PROGRAM Test_PID_Heatx\nVAR\n\tPID_0: PID_controller;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 20;\n\tA_room_with_a_view: HeatExchanger;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,\n    PV := A_room_with_a_view.PV,\n    Kc := 5.0,\n    Ti := 10.0,\n    Td := 1.0,\n    SampleTime := T#2000ms,\n    LowerLimit := 0,\n    UpperLimit := 150,\n    CO => ,  // 若不需要单独使用 CO 等输出，可留空，或根据需求定义变量接收\n    CO_P => ,\n    CO_I => ,\n    CO_D => \n);\n\n// 调用 HeatExchanger 功能块\nA_room_with_a_view(\n    Kp := 2.0,\n    Tp := 20,\n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heatx.st"], "repo": "PID_controller", "line_no": 5, "start_line_no": 0, "end_line_no": 30, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heatx.st_0-35", "title": "PID_controller-Progs\\Test_PID_Heatx.st", "text": "PROGRAM Test_PID_Heatx\nVAR\n\tPID_0: PID_controller;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 20;\n\tA_room_with_a_view: HeatExchanger;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,\n    PV := A_room_with_a_view.PV,\n    Kc := 5.0,\n    Ti := 10.0,\n    Td := 1.0,\n    SampleTime := T#2000ms,\n    LowerLimit := 0,\n    UpperLimit := 150,\n    CO => ,  // 若不需要单独使用 CO 等输出，可留空，或根据需求定义变量接收\n    CO_P => ,\n    CO_I => ,\n    CO_D => \n);\n\n// 调用 HeatExchanger 功能块\nA_room_with_a_view(\n    Kp := 2.0,\n    Tp := 20,\n    CO := PID_0.CO,\n    Dead_t := 9.8,\n    C := 2.048,\n    Sample_time := T#100ms,\n    PV => \n", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heatx.st"], "repo": "PID_controller", "line_no": 10, "start_line_no": 0, "end_line_no": 35, "window_size": 50, "slice_size": 5}]}
{"_id": "PID_controller_Progs_Test_PID_Heatx.st_0-36", "title": "PID_controller-Progs\\Test_PID_Heatx.st", "text": "PROGRAM Test_PID_Heatx\nVAR\n\tPID_0: PID_controller;\n\tProcess_out: REAL := 100;\n\tSetPoint: REAL := 20;\n\tA_room_with_a_view: HeatExchanger;\nEND_VAR\n\nVAR CONSTANT\nEND_VAR\n\nPID_0(\n    SP := SetPoint,\n    PV := A_room_with_a_view.PV,\n    Kc := 5.0,\n    Ti := 10.0,\n    Td := 1.0,\n    SampleTime := T#2000ms,\n    LowerLimit := 0,\n    UpperLimit := 150,\n    CO => ,  // 若不需要单独使用 CO 等输出，可留空，或根据需求定义变量接收\n    CO_P => ,\n    CO_I => ,\n    CO_D => \n);\n\n// 调用 HeatExchanger 功能块\nA_room_with_a_view(\n    Kp := 2.0,\n    Tp := 20,\n    CO := PID_0.CO,\n    Dead_t := 9.8,\n    C := 2.048,\n    Sample_time := T#100ms,\n    PV => \n);", "metadata": [{"fpath_tuple": ["PID_controller", "Progs\\Test_PID_Heatx.st"], "repo": "PID_controller", "line_no": 15, "start_line_no": 0, "end_line_no": 36, "window_size": 50, "slice_size": 5}]}
