{"prompt": "FUNCTION_BLOCK MouseEventHandler\nVAR_INPUT\n    xLeftClick : BOOL;      (* Left mouse button click *)\n    xRightClick : BOOL;     (* Right mouse button click *)\n    xMiddleClick : BOOL;    (* Middle mouse button click *)\n    xMouseMove : BOOL;      (* Mouse movement detected *)\n    rMouseX : REAL;         (* Current mouse X position *)\n    rMouseY : REAL;         (* Current mouse Y position *)\n    tDblClickTime : TIME := T#300MS;  (* Double click timeout *)\nEND_VAR\n\nVAR_OUTPUT\n    eMouseEvent : INT;      (* Event type: 0=None, 1=SingleClick, 2=DoubleClick, 3=RightClick, 4=MiddleClick *)\n    rEventX : REAL;         (* X position where event occurred *)\n    rEventY : REAL;         (* Y position where event occurred *)\n    xEventActive : BOOL;    (* TRUE when an event is active *)\nEND_VAR", "metadata": {"task_id": "VisuElements/0", "ground_truth": "FUNCTION_BLOCK MouseEventHandler\nVAR_INPUT\n    xLeftClick : BOOL;      (* Left mouse button click *)\n    xRightClick : BOOL;     (* Right mouse button click *)\n    xMiddleClick : BOOL;    (* Middle mouse button click *)\n    xMouseMove : BOOL;      (* Mouse movement detected *)\n    rMouseX : REAL;         (* Current mouse X position *)\n    rMouseY : REAL;         (* Current mouse Y position *)\n    tDblClickTime : TIME := T#300MS;  (* Double click timeout *)\nEND_VAR\n\nVAR_OUTPUT\n    eMouseEvent : INT;      (* Event type: 0=None, 1=SingleClick, 2=DoubleClick, 3=RightClick, 4=MiddleClick *)\n    rEventX : REAL;         (* X position where event occurred *)\n    rEventY : REAL;         (* Y position where event occurred *)\n    xEventActive : BOOL;    (* TRUE when an event is active *)\nEND_VAR\n\nVAR\n    LeftClickTimer : TON;\n    xLeftClickOld : BOOL;\n    iClickCount : INT := 0;\n    xEventProcessed : BOOL := FALSE;\nEND_VAR\n\n(* Reset event state *)\neMouseEvent := 0;\nxEventActive := FALSE;\n\n(* Handle left click events (single/double click) *)\nIF xLeftClick AND NOT xLeftClickOld THEN\n    (* First click detected *)\n    IF iClickCount = 0 THEN\n        LeftClickTimer(IN:=TRUE, PT:=tDblClickTime);\n        iClickCount := 1;\n    ELSE\n        (* Second click within time window *)\n        LeftClickTimer(IN:=FALSE);\n        eMouseEvent := 2; (* Double click *)\n        rEventX := rMouseX;\n        rEventY := rMouseY;\n        xEventActive := TRUE;\n        iClickCount := 0;\n        xEventProcessed := TRUE;\n    END_IF\nELSIF NOT xLeftClick AND xLeftClickOld THEN\n    (* Left button released *)\n    IF iClickCount = 1 AND NOT xEventProcessed THEN\n        LeftClickTimer();\n        IF NOT LeftClickTimer.Q THEN\n            (* Still waiting for potential double click *)\n            (* Will be handled by timer logic below *)\n        END_IF\n    END_IF\nEND_IF\n\n(* Check for double click timeout *)\nIF LeftClickTimer.Q AND iClickCount = 1 AND NOT xEventProcessed THEN\n    (* Timeout - single click confirmed *)\n    LeftClickTimer(IN:=FALSE);\n    eMouseEvent := 1; (* Single click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    iClickCount := 0;\nEND_IF\n\n(* Handle right click *)\nIF xRightClick AND NOT xEventProcessed THEN\n    eMouseEvent := 3; (* Right click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    xEventProcessed := TRUE;\nEND_IF\n\n(* Handle middle click *)\nIF xMiddleClick AND NOT xEventProcessed THEN\n    eMouseEvent := 4; (* Middle click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    xEventProcessed := TRUE;\nEND_IF\n\n(* Update old states *)\nxLeftClickOld := xLeftClick;\n\n(* Reset processed flag for next cycle *)\nxEventProcessed := FALSE;", "fpath_tuple": ["FUN", "MouseEventHandler.st"], "context_start_lineno": 0, "lineno": 19, "function_name": "MouseEventHandler", "line_no": 19}}
{"prompt": "FUNCTION RotationCalculation : BOOL\nVAR_INPUT\n    rCenterX : REAL;    (* X coordinate of rotation center *)\n    rCenterY : REAL;    (* Y coordinate of rotation center *)\n    rAngle : REAL;      (* Rotation angle in degrees *)\n    rPointX : REAL;     (* X coordinate of point to rotate *)\n    rPointY : REAL;     (* Y coordinate of point to rotate *)\nEND_VAR\n\nVAR_OUTPUT\n    rRotatedX : REAL;   (* X coordinate after rotation *)\n    rRotatedY : REAL;   (* Y coordinate after rotation *)\nEND_VAR", "metadata": {"task_id": "VisuElements/1", "ground_truth": "FUNCTION RotationCalculation : BOOL\nVAR_INPUT\n    rCenterX : REAL;    (* X coordinate of rotation center *)\n    rCenterY : REAL;    (* Y coordinate of rotation center *)\n    rAngle : REAL;      (* Rotation angle in degrees *)\n    rPointX : REAL;     (* X coordinate of point to rotate *)\n    rPointY : REAL;     (* Y coordinate of point to rotate *)\nEND_VAR\n\nVAR_OUTPUT\n    rRotatedX : REAL;   (* X coordinate after rotation *)\n    rRotatedY : REAL;   (* Y coordinate after rotation *)\nEND_VAR\n\nVAR\n    rRadians : REAL;\n    rCos : REAL;\n    rSin : REAL;\n    rTranslatedX : REAL;\n    rTranslatedY : REAL;\nEND_VAR\n\n(* Convert angle from degrees to radians *)\nrRadians := rAngle * 3.14159 / 180.0;\n\n(* Calculate sine and cosine *)\nrCos := COS(rRadians);\nrSin := SIN(rRadians);\n\n(* Translate point to origin (relative to center) *)\nrTranslatedX := rPointX - rCenterX;\nrTranslatedY := rPointY - rCenterY;\n\n(* Apply rotation matrix *)\nrRotatedX := rTranslatedX * rCos - rTranslatedY * rSin;\nrRotatedY := rTranslatedX * rSin + rTranslatedY * rCos;\n\n(* Translate back to original position *)\nrRotatedX := rRotatedX + rCenterX;\nrRotatedY := rRotatedY + rCenterY;\n\nRotationCalculation := TRUE;  (* Return success *)", "fpath_tuple": ["FUN", "RotationCalculation.st"], "context_start_lineno": 0, "lineno": 15, "function_name": "RotationCalculation", "line_no": 15}}
{"prompt": "FUNCTION_BLOCK NodeExpandCollapse\nVAR_INPUT\n    xNodeClick : BOOL;  (* Input signal for node click *)\n    tDblClickTime : TIME := T#500MS;  (* Time to wait for double click *)\nEND_VAR\n\nVAR_OUTPUT\n    xNodeExpand : BOOL;  (* Output: TRUE when node is expanded *)\n    xNodeSelected : BOOL; (* Output: TRUE when node is selected *)\nEND_VAR", "metadata": {"task_id": "VisuElements/2", "ground_truth": "FUNCTION_BLOCK NodeExpandCollapse\nVAR_INPUT\n    xNodeClick : BOOL;  (* Input signal for node click *)\n    tDblClickTime : TIME := T#500MS;  (* Time to wait for double click *)\nEND_VAR\n\nVAR_OUTPUT\n    xNodeExpand : BOOL;  (* Output: TRUE when node is expanded *)\n    xNodeSelected : BOOL; (* Output: TRUE when node is selected *)\nEND_VAR\n\nVAR\n    NodeDblClick : TON;\n    xNodeClickOld : BOOL;\n    iNodeState : INT := 1;\nEND_VAR\n\n(* This function block handles double-click expansion/collapse of a node *)\n\nCASE iNodeState OF\n\n    1: (* Wait for first click *)\n        IF xNodeClick AND NOT xNodeClickOld THEN\n            NodeDblClick(IN:=TRUE, PT:=tDblClickTime);\n            iNodeState := 2;\n            xNodeSelected := TRUE;\n        END_IF\n\n    2: (* Wait for second click or timeout *)\n        NodeDblClick();\n        IF NodeDblClick.Q THEN\n            (* Timeout - single click, reset *)\n            NodeDblClick(IN:=FALSE);\n            xNodeClickOld := FALSE;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        ELSIF NOT xNodeClick AND xNodeClickOld THEN\n            (* Second click detected - toggle expansion *)\n            NodeDblClick(IN:=FALSE);\n            xNodeExpand := NOT xNodeExpand;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        END_IF\nEND_CASE\n\nxNodeClickOld := xNodeClick;", "fpath_tuple": ["FUN", "NodeExpandCollapse.st"], "context_start_lineno": 0, "lineno": 12, "function_name": "NodeExpandCollapse", "line_no": 12}}
