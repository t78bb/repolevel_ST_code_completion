[["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV: REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\n\tdeadTimeElapsed: TIME := T#0ms;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time) / millis;\n\tA := EXP(-delta_t / Tp);\n\tB := 1 - A;\n\n\tIF (deadTimeElapsed >= Dead_t) THEN\n\t\tPV := A * lastPV + B * Kp * CO + C;\n\t\tlastPV := PV;\n\tELSE\n\t\tdeadTimeElapsed := deadTimeElapsed + Sample_time;\n\tEND_IF;\n\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := REAL_TO_TIME((now - lastTime)) / millis;\n\theat_flow := Heat_In + U * (Temp_Out - Temp_In);\n\tTemp := Temp_In + (heat_flow * delta_t / TC);\n\tlastTime := now;\nEND_IF;\nRETURN;\n```"], ["```\nVAR\n\tlastErr: REAL := 0; //Previous error\n\tintegral: REAL := 0; //Integral accumulator\n\tdeltaTime: REAL := 0; //Time difference\n\tdeltaPV: REAL := 0; //Change in process variable\nEND_VAR\n\nnow := TIME(); //Current time\ndeltaTime := REAL_TO_TIME(now - lastTime) / millis; //Calculate elapsed time in seconds\n\n// Calculate error\nerr := SP - PV;\n\n// Proportional term\nCO_P := Kc * err;\n\n// Integral term with anti-windup\nintegral := integral + (err * deltaTime);\nIF integral > UpperLimit THEN\n\tintegral := UpperLimit;\nELSIF integral < LowerLimit THEN\n\tintegral := LowerLimit;\nEND_IF;\nCO_I := Kc * (integral / Ti);\n\n// Derivative term\ndeltaPV := PV - lastErr;\nCO_D := -Kc * (Td * deltaPV / deltaTime);\n\n// Calculate total controller output\nCO := CO_P + CO_I + CO_D;\n\n// Apply output limits\nIF CO > UpperLimit THEN\n\tCO := UpperLimit;\nELSIF CO < LowerLimit THEN\n\tCO := LowerLimit;\nEND_IF;\n\n// Update last values\nlastErr := PV;\nlastTime := now;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0ms;\n\tproc_sum_in: REAL := 0.0;\n\tproc_sum_out: REAL := 0.0;\n\ttemp: REAL := 0.0;\n\tmillis: UINT := 1000;\n\tproc_out: REAL := 0.0;\nEND_VAR\n\nnow := TIME();\nIF (now - lastTime) >= SampleTime THEN\n\t// Update the fluid level based on input and output flow rates\n\tLevel := Level + TIME_TO_REAL(SampleTime) / millis * (Process_In - Process_Out);\n\t\n\t// Ensure the level does not exceed the defined limits\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\t\n\t// Update the last time variable\n\tlastTime := now;\nEND_IF;\n```"]]