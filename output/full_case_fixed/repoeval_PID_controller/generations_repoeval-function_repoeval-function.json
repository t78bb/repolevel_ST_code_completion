[["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV: REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\n\tDeadTimeElapsed: TIME := T#0ms;\n\tDeadTimeActive: BOOL := FALSE;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time) / millis;\n\tA := EXP(-delta_t / Tp);\n\tB := 1 - A;\n\n\tIF DeadTimeActive THEN\n\t\tDeadTimeElapsed := DeadTimeElapsed + Sample_time;\n\t\tIF DeadTimeElapsed >= Dead_t THEN\n\t\t\tDeadTimeActive := FALSE;\n\t\t\tDeadTimeElapsed := T#0ms;\n\t\tEND_IF\n\tEND_IF\n\n\tIF NOT DeadTimeActive THEN\n\t\tPV := A * lastPV + B * Kp * CO + C;\n\t\tlastPV := PV;\n\t\tDeadTimeActive := TRUE;\n\tEND_IF\n\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := REAL_TO_TIME((now - lastTime)) / millis;\n\theat_flow := Heat_In + U * (Temp_Out - Temp_In);\n\tTemp := Temp_In + (heat_flow / TC) * delta_t;\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tlastErr: REAL := 0; //Previous error\n\tintegral: REAL := 0; //Integral accumulator\n\tdeltaTime: REAL := 0; //Time difference in seconds\n\tdeltaPV: REAL := 0; //Change in process variable\nEND_VAR\n\nnow := TIME(); //Get current time\ndeltaTime := REAL_TO_TIME((now - lastTime)) / millis; //Calculate elapsed time in seconds\n\nIF deltaTime >= REAL_TO_TIME(SampleTime) THEN\n\t// Calculate error\n\terr := SP - PV;\n\n\t// Proportional term\n\tCO_P := Kc * err;\n\n\t// Integral term with anti-windup\n\tintegral := integral + (err * deltaTime);\n\tIF integral > UpperLimit THEN\n\t\tintegral := UpperLimit;\n\tELSIF integral < LowerLimit THEN\n\t\tintegral := LowerLimit;\n\tEND_IF;\n\tCO_I := (Kc / Ti) * integral;\n\n\t// Derivative term\n\tdeltaPV := PV - lastErr;\n\tCO_D := -(Kc * Td * deltaPV / deltaTime);\n\n\t// Compute total output\n\tCO := CO_P + CO_I + CO_D;\n\n\t// Apply output limits\n\tIF CO > UpperLimit THEN\n\t\tCO := UpperLimit;\n\tELSIF CO < LowerLimit THEN\n\t\tCO := LowerLimit;\n\tEND_IF;\n\n\t// Update last values\n\tlastErr := PV;\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0ms;\n\tmillis: UINT := 1000;\n\ttemp: REAL;\nEND_VAR\n\nnow := TIME();\nIF (now - lastTime) >= SampleTime THEN\n\ttemp := TIME_TO_REAL(SampleTime) / millis * (Process_In - Process_Out);\n\tLevel := Level + temp;\n\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\n\tlastTime := now;\nEND_IF;\n```"]]