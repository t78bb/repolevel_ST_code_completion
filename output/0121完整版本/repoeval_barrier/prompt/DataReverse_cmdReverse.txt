This is the known requirement information for the function to be completed:\nThis code is intended to implement a function that reverses the direction of a given input command between "extend" and "retract".\nContinue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# modbus-FUN\DataReverse_cmdReverse.st
# --------------------------------------------------
# FUNCTION cmdReverse : TargetDirect
# VAR_INPUT
# 	input		:TargetDirect;
# END_VAR
# 
# IF input = TargetDirect.extend THEN
# 	cmdReverse := TargetDirect.retract;
# END_IF
# IF input = TargetDirect.retract THEN
# 	cmdReverse := TargetDirect.extend;
# END_IF
# --------------------------------------------------
# the below code fragment can be found in:
# modbus-FUN\DataReverse.st
# --------------------------------------------------
# FUNCTION_BLOCK DataReverse
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# END_VAR
# 
# --------------------------------------------------
# the below code fragment can be found in:
# core-PRG\Barrier_manualExecute_method.st
# --------------------------------------------------
# METHOD manualExecute
# VAR_INPUT
# END_VAR
# VAR
# 	//targetDirect		:TargetDirect;
# END_VAR
# 
# FOR gi := 1 TO 10 DO
# 	IF gUI.grd[gi].pwrEnable THEN
# 		cmdExecutor0(level := 1, idx := gi, 
# 					direct := gDev.grd[gi].vector, 
# 					percent := gUI.grd[gi].pwrPercent);
# 	ELSE
# 		cmdExecutor0(level := 1, idx := gi, direct := 3, percent := 0);		
# 	END_IF
# END_FOR
# 
# FOR si := 0 TO 10 DO
# 	IF gUI.sky[si].pwrEnable THEN
# 		cmdExecutor0(level := 2, idx := si, 
# 					direct := gDev.sky[si].vector, 
# 					percent := gUI.sky[si].pwrPercent);	
# 	ELSE
# 		cmdExecutor0(level := 2, idx := si, direct := 3, percent := 0);		
# 	END_IF
# 
# --------------------------------------------------
# the below code fragment can be found in:
# core-PRG\Barrier_manualExecute_method.st
# --------------------------------------------------
# METHOD manualExecute
# VAR_INPUT
# END_VAR
# VAR
# 	//targetDirect		:TargetDirect;
# END_VAR
# 
# FOR gi := 1 TO 10 DO
# 	IF gUI.grd[gi].pwrEnable THEN
# 		cmdExecutor0(level := 1, idx := gi, 
# 					direct := gDev.grd[gi].vector, 
# 					percent := gUI.grd[gi].pwrPercent);
# 	ELSE
# 		cmdExecutor0(level := 1, idx := gi, direct := 3, percent := 0);		
# 	END_IF
# END_FOR
# 
# FOR si := 0 TO 10 DO
# 	IF gUI.sky[si].pwrEnable THEN
# 		cmdExecutor0(level := 2, idx := si, 
# 					direct := gDev.sky[si].vector, 
# 					percent := gUI.sky[si].pwrPercent);	
# 	ELSE
# 		cmdExecutor0(level := 2, idx := si, direct := 3, percent := 0);		
# 	END_IF
# END_FOR
# 
# 
# --------------------------------------------------
# the below code fragment can be found in:
# core-PRG\Barrier_pidExecute_method.st
# --------------------------------------------------
# METHOD pidExecute
# VAR_INPUT
# END_VAR
# VAR
# 	vector 		:TargetDirect;
# END_VAR
# 
# FOR gi := 1 TO 10 DO
# 	IF gDev.grd[gi].ctrl.isError THEN
# 		CONTINUE;
# 	END_IF
# 	cmdExecutor(level := 1, idx := gi, percent := grdPid[gi].res);
# END_FOR
# 
# 
# FOR si := 1 TO 10 DO
# 	IF gDev.sky[si].ctrl.isError THEN
# 		CONTINUE;
# 	END_IF
# 	cmdExecutor(level := 2, idx := si, percent := skyPid[si].res);
# END_FOR
# 
# //起竖挡板执行开关量
# IF NOT gDev.sky[0].ctrl.isError THEN
# 	IF gDev.sky[0].vector = TargetDirect.extend THEN
# 
# --------------------------------------------------


FUNCTION cmdReverse : TargetDirect
VAR_INPUT
	input		:TargetDirect;
END_VAR
```