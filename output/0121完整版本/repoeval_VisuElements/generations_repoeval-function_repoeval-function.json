[["```\nVAR\n    LeftClickTimer : TON;\n    xLeftClickOld : BOOL;\n    iClickCount : INT := 0;\n    xEventProcessed : BOOL := FALSE;\n    xRightClickOld : BOOL;\n    xMiddleClickOld : BOOL;\n    xMouseMoveOld : BOOL;\nEND_VAR\n\n(* Reset event state *)\neMouseEvent := 0;\nxEventActive := FALSE;\n\n(* Handle left click events (single/double click) *)\nIF xLeftClick AND NOT xLeftClickOld THEN\n    IF iClickCount = 0 THEN\n        LeftClickTimer(IN := TRUE, PT := tDblClickTime);\n        iClickCount := 1;\n    ELSE\n        LeftClickTimer(IN := FALSE);\n        eMouseEvent := 2; (* Double click *)\n        rEventX := rMouseX;\n        rEventY := rMouseY;\n        xEventActive := TRUE;\n        iClickCount := 0;\n        xEventProcessed := TRUE;\n    END_IF\nELSIF NOT xLeftClick AND xLeftClickOld THEN\n    IF iClickCount = 1 AND NOT xEventProcessed THEN\n        LeftClickTimer();\n        IF NOT LeftClickTimer.Q THEN\n            (* Waiting for potential double click *)\n        END_IF\n    END_IF\nEND_IF\n\nIF LeftClickTimer.Q AND iClickCount = 1 THEN\n    eMouseEvent := 1; (* Single click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    iClickCount := 0;\nEND_IF\n\n(* Handle right click events *)\nIF xRightClick AND NOT xRightClickOld THEN\n    eMouseEvent := 3; (* Right click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\nEND_IF\n\n(* Handle middle click events *)\nIF xMiddleClick AND NOT xMiddleClickOld THEN\n    eMouseEvent := 4; (* Middle click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\nEND_IF\n\n(* Handle mouse movement events *)\nIF xMouseMove AND NOT xMouseMoveOld THEN\n    eMouseEvent := 0; (* Mouse movement does not trigger an event type *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\nEND_IF\n\n(* Update old states *)\nxLeftClickOld := xLeftClick;\nxRightClickOld := xRightClick;\nxMiddleClickOld := xMiddleClick;\nxMouseMoveOld := xMouseMove;\n```"], ["```\nVAR\n    NodeDblClick : TON;\n    xNodeClickOld : BOOL;\n    iNodeState : INT := 1;\nEND_VAR\n\nCASE iNodeState OF\n    1: (* Wait for first click *)\n        IF xNodeClick AND NOT xNodeClickOld THEN\n            NodeDblClick(IN := TRUE, PT := tDblClickTime);\n            iNodeState := 2;\n            xNodeSelected := TRUE;\n        END_IF\n\n    2: (* Wait for second click or timeout *)\n        NodeDblClick();\n        IF NodeDblClick.Q THEN\n            (* Timeout - single click, reset *)\n            NodeDblClick(IN := FALSE);\n            xNodeClickOld := FALSE;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        ELSIF NOT xNodeClick AND xNodeClickOld THEN\n            (* Second click detected - toggle expansion *)\n            NodeDblClick(IN := FALSE);\n            xNodeExpand := NOT xNodeExpand;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        END_IF\nEND_CASE\n\nxNodeClickOld := xNodeClick;\n```"], ["```\nVAR\n    rRadians : REAL;\n    rCos : REAL;\n    rSin : REAL;\n    rTranslatedX : REAL;\n    rTranslatedY : REAL;\nEND_VAR\n\nrRadians := rAngle * PI / 180.0; (* Convert angle from degrees to radians *)\nrCos := COS(rRadians);          (* Calculate cosine of the angle *)\nrSin := SIN(rRadians);          (* Calculate sine of the angle *)\n\n(* Translate point to origin relative to the rotation center *)\nrTranslatedX := rPointX - rCenterX;\nrTranslatedY := rPointY - rCenterY;\n\n(* Perform rotation *)\nrRotatedX := rTranslatedX * rCos - rTranslatedY * rSin + rCenterX;\nrRotatedY := rTranslatedX * rSin + rTranslatedY * rCos + rCenterY;\n\nRETURN TRUE; (* Indicate successful calculation *)\n```"]]