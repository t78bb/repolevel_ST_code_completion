[["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV: REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\n\tdead_time_elapsed: TIME := T#0ms;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time) / millis;\n\tA := EXP(-delta_t / Tp);\n\tB := 1 - A;\n\n\tIF dead_time_elapsed >= Dead_t THEN\n\t\tPV := A * lastPV + B * Kp * CO + C;\n\t\tlastPV := PV;\n\tELSE\n\t\tdead_time_elapsed := dead_time_elapsed + Sample_time;\n\tEND_IF;\n\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\nEND_VAR\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := REAL_TO_TIME((now - lastTime)) / millis;\n\tlastTime := now;\n\n\t// Calculate heat flow based on thermal conductance and temperature difference\n\theat_flow := U * (Temp_Out - Temp_In);\n\n\t// Update temperature using heat input, heat flow, and thermal capacity\n\tTemp := Temp_In + ((Heat_In - heat_flow) * delta_t / TC);\n\n\t// Store the last temperature for reference\n\tlastTemp := Temp;\nEND_IF;\n```"], ["```\nVAR\n\tlastErr: REAL := 0; //Previous error\n\tintegral: REAL := 0; //Integral accumulator\n\tdeltaTime: REAL := 0; //Time difference in seconds\n\tdeltaPV: REAL := 0; //Change in process variable\nEND_VAR\n\nnow := TIME(); //Current time\ndeltaTime := REAL_TO_REAL((now - lastTime) / millis); //Convert time difference to seconds\n\n// Calculate error\nerr := SP - PV;\n\n// Proportional term\nCO_P := Kc * err;\n\n// Integral term with anti-windup\nintegral := integral + (err * deltaTime);\nIF integral > UpperLimit THEN\n\tintegral := UpperLimit;\nELSIF integral < LowerLimit THEN\n\tintegral := LowerLimit;\nEND_IF;\nCO_I := (Kc / Ti) * integral;\n\n// Derivative term\ndeltaPV := PV - lastErr;\nCO_D := (-Kc * Td) * (deltaPV / deltaTime);\n\n// Calculate total controller output\nCO := CO_P + CO_I + CO_D;\n\n// Apply output limits\nIF CO > UpperLimit THEN\n\tCO := UpperLimit;\nELSIF CO < LowerLimit THEN\n\tCO := LowerLimit;\nEND_IF;\n\n// Update previous values\nlastErr := PV;\nlastTime := now;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tproc_sum_in: REAL := 0;\n\tproc_sum_out: REAL := 0;\n\ttemp: REAL := 0;\n\tmillis: UINT := 1000;\n\tproc_out: REAL := 0;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > SampleTime) THEN\n\tLevel := Level + TIME_TO_REAL(SampleTime) / millis * (Process_In - Process_Out);\n\t\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\t\n\tlastTime := now;\nEND_IF;\n```"]]