This is the known requirement information for the function to be completed:
This code is intended to implement a calculation for the radius based on the distances, height positions, material thickness, and height offset using a specific mathematical formula.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:
1. 计算轴位置变化量，公式为 lDeltaH := ABS(lHnew - lHold)。
2. 计算总的有效高度，公式为 lEffectiveHeight := lDeltaH + lTk + lOffset。
3. 根据两轴中心距离 lD 和有效高度 lEffectiveHeight，计算半径，公式为 lRadius := SQRT((lD / 2)^2 + lEffectiveHeight^2)。
4. 返回计算得到的半径值 lRadius。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# 开放式双轴卷绕机编程开发实训-FUN\F_CalculateRadius.st
# --------------------------------------------------
# FUNCTION F_CalculateRadius : LREAL
# VAR_INPUT
# 	lD				:	LREAL;		//两轴中心距离
# 	lHold			:	LREAL;		//测量开始时的AxisV位置
# 	lHnew			:	LREAL;		//测量结束时的AxisV位置
# 	lTk				:	LREAL;		//材料厚度
# 	lOffset			:	LREAL;		//高度偏移量
# END_VAR
# 
# // 半径计算公式：
# // R = |√(D²+(Hnew+offset)²) - √(D²+(Hold+offset)²)| / π + Tk
# F_CalculateRadius := ABS(SQRT(EXPT(lD,2)+EXPT(lHnew+lOffset,2)) - SQRT(EXPT(lD,2)+EXPT(lHold+lOffset,2))) / SMC_PI + lTk;
# 
# 
# --------------------------------------------------
# the below code fragment can be found in:
# 开放式双轴卷绕机编程开发实训-FUN\F_CompensateVelocity.st
# --------------------------------------------------
# FUNCTION F_CompensateVelocity : LREAL
# VAR_INPUT
# 	lCurrentVel		:	LREAL;		//当前速度
# 	lOldPos			:	LREAL;		//上一次位置
# 	lNewPos			:	LREAL;		//当前位置
# 	lRadius			:	LREAL;		//当前半径
# 	lTk				:	LREAL;		//材料厚度
# 	bUnwinding		:	BOOL;		//TRUE=放卷（半径减小），FALSE=收卷（半径增加）
# END_VAR
# 
# // 检查轴是否在运动（位置是否变化）
# IF lOldPos > lNewPos THEN
# 	IF bUnwinding THEN
# 		// 放卷：半径减小，速度需要增加
# 		// 公式：V_new = V_old + V_old * Tk / (R - Tk)
# 		IF (lRadius - lTk) > 0.01 THEN  // 避免除零
# 			F_CompensateVelocity := lCurrentVel + lCurrentVel * lTk / (lRadius - lTk);
# 		ELSE
# 			F_CompensateVelocity := lCurrentVel;
# 		END_IF
# 	ELSE
# 		// 收卷：半径增加，速度需要降低
# 		// 公式：V_new = V_old - V_old * Tk / (R + Tk)
# 		F_CompensateVelocity := lCurrentVel - lCurrentVel * lTk / (lRadius + lTk);
# 	END_IF
# 
# --------------------------------------------------
# the below code fragment can be found in:
# 开放式双轴卷绕机编程开发实训-FUN\F_CompensateVelocity.st
# --------------------------------------------------
# FUNCTION F_CompensateVelocity : LREAL
# VAR_INPUT
# 	lCurrentVel		:	LREAL;		//当前速度
# 	lOldPos			:	LREAL;		//上一次位置
# 	lNewPos			:	LREAL;		//当前位置
# 	lRadius			:	LREAL;		//当前半径
# 	lTk				:	LREAL;		//材料厚度
# 	bUnwinding		:	BOOL;		//TRUE=放卷（半径减小），FALSE=收卷（半径增加）
# END_VAR
# 
# // 检查轴是否在运动（位置是否变化）
# IF lOldPos > lNewPos THEN
# 	IF bUnwinding THEN
# 		// 放卷：半径减小，速度需要增加
# 		// 公式：V_new = V_old + V_old * Tk / (R -

FUNCTION F_CalculateRadius : LREAL
VAR_INPUT
	lD				:	LREAL;		//两轴中心距离
	lHold			:	LREAL;		//测量开始时的AxisV位置
	lHnew			:	LREAL;		//测量结束时的AxisV位置
	lTk				:	LREAL;		//材料厚度
	lOffset			:	LREAL;		//高度偏移量
END_VAR
```