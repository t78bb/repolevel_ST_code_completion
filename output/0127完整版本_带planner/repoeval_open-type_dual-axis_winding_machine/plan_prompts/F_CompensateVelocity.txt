你是 IEC 61131-3 / CODESYS ST 领域的高级架构师，现在需要为一个函数块/函数编写**实现步骤规划**，帮助后续代码生成更贴近真实 ground truth。

==================== 基本信息 ====================
- 项目名称: open-type_dual-axis_winding_machine
- 函数类型: function
- 函数名: F_CompensateVelocity

==================== 需求说明（requirement） ====================
This code is intended to implement velocity compensation based on positional changes, material thickness, and radius adjustments during unwinding or rewinding operations.

==================== 已有声明部分====================
```st
FUNCTION F_CompensateVelocity : LREAL
VAR_INPUT
	lCurrentVel		:	LREAL;		//当前速度
	lOldPos			:	LREAL;		//上一次位置
	lNewPos			:	LREAL;		//当前位置
	lRadius			:	LREAL;		//当前半径
	lTk				:	LREAL;		//材料厚度
	bUnwinding		:	BOOL;		//TRUE=放卷（半径减小），FALSE=收卷（半径增加）
END_VAR
```

==================== 调用上下文窗口（来自项目代码） ====================
【上下文片段 1】
- 文件: project_code\open-type_dual-axis_winding_machine\PRG\PLC_PRG.st
- 行号: 154
- 类型: call
```st
10://初始速度
			AxisMVel:=MHmiInVel;
			AxisSVel:=-1*AxisMVel*Mr/Sr;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			AxisVOldPoint:=AxisV.fActPosition;
			AxisPID1(RESET:=TRUE);
			iStatus:=11;		
		11://同步控制
			// 使用F_CompensateVelocity函数进行速度补偿
			AxisMVel := F_CompensateVelocity(lCurrentVel:=AxisMVel, lOldPos:=AxisMOldPoint, lNewPos:=AxisM.fActPosition, lRadius:=Mr, lTk:=Tk, bUnwinding:=TRUE);
			AxisSVel := F_CompensateVelocity(lCurrentVel:=AxisSVel, lOldPos:=AxisSOldPoint, lNewPos:=AxisS.fActPosition, lRadius:=Sr, lTk:=Tk, bUnwinding:=FALSE);
			
			fbAxisMFollowVelocity(Axis:=AxisM,bExecute:=TRUE,fSetVelocity:=AxisMVel);
			fbAxisSFollowVelocity(Axis:=AxisS,bExecute:=TRUE,fSetVelocity:=AxisSVel);
			AxisPID1(ACTUAL:=AxisV.fActPosition,SET_POINT:=AxisVOldPoint,KP:=0.1,RESET:=FALSE,TN:=3,TV:=0,CYCLE:=0.004,Y=>PIDOut);
		//	AxisMVel:=AxisMVel+PIDOut;
			AxisSVel:=AxisSVel-PIDOut;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			fbLIORtrig(CLK:=LFlage);
```

【上下文片段 2】
- 文件: project_code\open-type_dual-axis_winding_machine\PRG\PLC_PRG.st
- 行号: 155
- 类型: call
```st
AxisMVel:=MHmiInVel;
			AxisSVel:=-1*AxisMVel*Mr/Sr;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			AxisVOldPoint:=AxisV.fActPosition;
			AxisPID1(RESET:=TRUE);
			iStatus:=11;		
		11://同步控制
			// 使用F_CompensateVelocity函数进行速度补偿
			AxisMVel := F_CompensateVelocity(lCurrentVel:=AxisMVel, lOldPos:=AxisMOldPoint, lNewPos:=AxisM.fActPosition, lRadius:=Mr, lTk:=Tk, bUnwinding:=TRUE);
			AxisSVel := F_CompensateVelocity(lCurrentVel:=AxisSVel, lOldPos:=AxisSOldPoint, lNewPos:=AxisS.fActPosition, lRadius:=Sr, lTk:=Tk, bUnwinding:=FALSE);
			
			fbAxisMFollowVelocity(Axis:=AxisM,bExecute:=TRUE,fSetVelocity:=AxisMVel);
			fbAxisSFollowVelocity(Axis:=AxisS,bExecute:=TRUE,fSetVelocity:=AxisSVel);
			AxisPID1(ACTUAL:=AxisV.fActPosition,SET_POINT:=AxisVOldPoint,KP:=0.1,RESET:=FALSE,TN:=3,TV:=0,CYCLE:=0.004,Y=>PIDOut);
		//	AxisMVel:=AxisMVel+PIDOut;
			AxisSVel:=AxisSVel-PIDOut;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			fbLIORtrig(CLK:=LFlage);
			IF fbLIORtrig.Q THEN
```

【上下文片段 3】
- 文件: project_code\open-type_dual-axis_winding_machine\PRG\PLC_PRG.st
- 行号: 244
- 类型: call
```st
22:
			AxisSVel:=MHmiInVel;
			AxisMVel:=-1*AxisSVel*Sr/Mr;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			AxisVOldPoint:=AxisV.fActPosition;
			AxisPID2(RESET:=TRUE);
			iStatus:=23;
		23:
			// 使用F_CompensateVelocity函数进行速度补偿（反向）
			AxisSVel := F_CompensateVelocity(lCurrentVel:=AxisSVel, lOldPos:=AxisSOldPoint, lNewPos:=AxisS.fActPosition, lRadius:=Sr, lTk:=Tk, bUnwinding:=TRUE);
			AxisMVel := F_CompensateVelocity(lCurrentVel:=AxisMVel, lOldPos:=AxisMOldPoint, lNewPos:=AxisM.fActPosition, lRadius:=Mr, lTk:=Tk, bUnwinding:=FALSE);
			
			fbAxisMFollowVelocity(Axis:=AxisM,bExecute:=TRUE,fSetVelocity:=AxisMVel);
			fbAxisSFollowVelocity(Axis:=AxisS,bExecute:=TRUE,fSetVelocity:=AxisSVel);
			AxisPID2(ACTUAL:=AxisV.fActPosition,SET_POINT:=AxisVOldPoint,KP:=0.1,TN:=3,TV:=0,RESET:=FALSE,CYCLE:=0.004,Y=>PIDOut);
			//AxisSVel:=AxisSVel+PIDOut;
			AxisMVel:=AxisMVel-PIDOut;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			fbRIORtrig(CLK:=RFlage);
```

【上下文片段 4】
- 文件: project_code\open-type_dual-axis_winding_machine\PRG\PLC_PRG.st
- 行号: 245
- 类型: call
```st
AxisSVel:=MHmiInVel;
			AxisMVel:=-1*AxisSVel*Sr/Mr;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			AxisVOldPoint:=AxisV.fActPosition;
			AxisPID2(RESET:=TRUE);
			iStatus:=23;
		23:
			// 使用F_CompensateVelocity函数进行速度补偿（反向）
			AxisSVel := F_CompensateVelocity(lCurrentVel:=AxisSVel, lOldPos:=AxisSOldPoint, lNewPos:=AxisS.fActPosition, lRadius:=Sr, lTk:=Tk, bUnwinding:=TRUE);
			AxisMVel := F_CompensateVelocity(lCurrentVel:=AxisMVel, lOldPos:=AxisMOldPoint, lNewPos:=AxisM.fActPosition, lRadius:=Mr, lTk:=Tk, bUnwinding:=FALSE);
			
			fbAxisMFollowVelocity(Axis:=AxisM,bExecute:=TRUE,fSetVelocity:=AxisMVel);
			fbAxisSFollowVelocity(Axis:=AxisS,bExecute:=TRUE,fSetVelocity:=AxisSVel);
			AxisPID2(ACTUAL:=AxisV.fActPosition,SET_POINT:=AxisVOldPoint,KP:=0.1,TN:=3,TV:=0,RESET:=FALSE,CYCLE:=0.004,Y=>PIDOut);
			//AxisSVel:=AxisSVel+PIDOut;
			AxisMVel:=AxisMVel-PIDOut;
			AxisMOldPoint:=AxisM.fActPosition;
			AxisSOldPoint:=AxisS.fActPosition;
			fbRIORtrig(CLK:=RFlage);
			IF fbRIORtrig.Q THEN
```

==================== 核心编写规则（必须严格遵守） ====================
1. 步骤仅聚焦函数 / 函数块的核心执行逻辑，不包含：
- 额外的 “约束和假设”“无状态特性” 等非执行步骤内容；
- 对调用场景的冗余描述（如 “提供给主程序用于显示” 这类无执行意义的内容）；
- 重复的校验逻辑（如已校验非负则无需再提 “强制设为零” 之外的解释）。
2. 每一步仅描述一个独立的操作 / 逻辑，语言简洁、无修饰，直接说明 “做什么”；
3. 步骤中引用的变量名、类型必须与声明部分 / 调用上下文完全一致；
4. 步骤数量控制在 3-6 步，仅保留核心逻辑，剔除所有非必要的补充说明。

==================== 你的任务 ====================
1. 基于上述需求、声明和调用上下文，推断该函数块/函数在整个项目中的职责、输入输出意义以及与其他模块的交互关系。
2. 给出一个**分步骤的功能规划/设计说明**，每一步都要尽量贴近调用场景。
3. 规划结果要适合后续直接转换为 ST 实现代码，注意：
   - 不要给出具体 ST 代码，只写步骤/逻辑。
   - 引用调用上下文中的变量名、调用方式，保持语义一致。
   - 如果发现调用方式隐含了某些约束（例如只在某些状态下调用），在规划里明确写出。

==================== 输出格式要求 ====================
请严格使用如下中文结构化格式输出（不要添加多余解释）：

功能规划:
1. ...
2. ...
3. ...
N. ...