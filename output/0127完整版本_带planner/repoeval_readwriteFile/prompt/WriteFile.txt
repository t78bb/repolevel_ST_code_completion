This is the known requirement information for the function to be completed:
This code is intended to implement a file writing operation that writes a specified number of bytes from a buffer to a file, with error handling and status signaling.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:
1. 检查 `bExec` 触发变量，确认函数块是否被激活。
2. 初始化文件写入操作，打开文件路径 `fileName` 进行写入准备。
3. 从输入缓冲区 `writeBuffer` 提取 `writeNum` 指定字节的数据。
4. 执行写操作，将提取的数据写入到指定文件。
5. 检查写入操作结果，根据成功或失败设置状态标志（例如 `bDone`, `bBusy`）。
6. 关闭文件，清理资源。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# 读写文件-FUN\WriteFile.st
# --------------------------------------------------
# FUNCTION_BLOCK WriteFile
# VAR_INPUT
# 	bExec	:	BOOL;//功能块触发变量
# 	writeBuffer	:	ARRAY[0..255] OF BYTE;//写数缓冲区
# 	writeNum	:	UDINT;//写入数据的字节数
# 	fileName	:	STRING;//文件的路径
# END_VAR
# VAR
# 	nState	:	BYTE;
# 	fileHandle	:	UDINT;//文件句柄
# 	nNumWrite	:	UDINT;//写入文件的字节数
# 	i	:	BYTE;//定义循环变量
# 	fbRtrig	:	R_TRIG;//实例化上升沿触发功能块
# END_VAR
# VAR_OUTPUT
# 	bDone	:	BOOL;//写入成功
# 	bBusy	:	BOOL;//写入忙
# 	bErr	:	BOOL;//写入出错
# 	nErrId	:	UDINT;//错误代码
# END_VAR
# 
# CASE nState OF
# 	0:
# 		fbRtrig(CLK := bExec);//等待用户触发调用
# 		IF fbRtrig.Q THEN
# 			nState := 1;
# 			bBusy := TRUE;
# 			bErr := FALSE;
# 			nErrId := 0;
# 			bDone := FALSE;
# 
# --------------------------------------------------
# the below code fragment can be found in:
# 读写文件-FUN\WriteFile.st
# --------------------------------------------------
# FUNCTION_BLOCK WriteFile
# VAR_INPUT
# 	bExec	:	BOOL;//功能块触发变量
# 	writeBuffer	:	ARRAY[0..255] OF BYTE;//写数缓冲区
# 	writeNum	:	UDINT;//写入数据的字节数
# 	fileName	:	STRING;//文件的路径
# END_VAR
# VAR
# 	nState	:	BYTE;
# 	fileHandle	:	UDINT;//文件句柄
# 	nNumWrite	:	UDINT;//写入文件的字节数
# 	i	:	BYTE;//定义循环变量
# 	fbRtrig	:	R_TRIG;//实例化上升沿触发功能块
# END_VAR
# VAR_OUTPUT
# 	bDone	:	BOOL;//写入成功
# 	bBusy	:	BOOL;//写入忙
# 	bErr	:	BOOL;//写入出错
# 	nErrId	:	UDINT;//错误代码
# END_VAR
# 
# CASE nState OF
# 	0:
# 		fbRtrig(CLK := bExec);//等待用户触发调用
# 		IF fbRtrig.Q THEN
# 
# --------------------------------------------------
# the below code fragment can be found in:
# 读写文件-FUN\WriteFile.st
# --------------------------------------------------
# FUNCTION_BLOCK WriteFile
# VAR_INPUT
# 	bExec	:	BOOL;//功能块触发变量
# 	writeBuffer	:	ARRAY[0..255] OF BYTE;//写数缓冲区
# 	writeNum	:	UDINT;//写入数据的字节数
# 	fileName	:	STRING;//文件的路径
# END_VAR
# VAR
# 	nState	:	BYTE;
# 	fileHandle	:	UDINT;//文件句柄
# 	nNumWrite	:	UDINT;//写入文件的字节数
# 	i	:	BYTE;//定义循环变量
# 	fbRtrig	:	R_TRIG;//实例化上升沿触发功能块
# END_VAR
# VAR_OUTPUT
# 	bDone	:	BOOL;//写入成功
# 	bBusy	:	BOOL;//写入忙
# 	bErr	:	BOOL;//写入出错
# 	nErrId	:	UDINT;//错误代码
# END_VAR
# 
# CASE nState OF
# 	0:
# 		fbRtrig(CLK := bExec);//等待用户触发调用
# 		IF fbRtrig.Q THEN
# 			nState := 1;
# 			bBusy := TRUE;
# 			bErr := FALSE;
# 			nErrId := 0

FUNCTION_BLOCK WriteFile
VAR_INPUT
	bExec	:	BOOL;//功能块触发变量
	writeBuffer	:	ARRAY[0..255] OF BYTE;//写数缓冲区
	writeNum	:	UDINT;//写入数据的字节数
	fileName	:	STRING;//文件的路径
END_VAR
```