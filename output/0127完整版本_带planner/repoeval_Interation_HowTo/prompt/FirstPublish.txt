This is the known requirement information for the function to be completed:
This code is intended to implement an MQTT message publishing functionality with a predefined topic, payload, and quality of service settings.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:
1. 初始化 MQTT 发布的必要参数，包括 Topic、Payload 和 QoS。
2. 检查 MQTT_IN_OUT.clientFB 的连接状态，确保客户端正确连接至指定 URL。
3. 检验 MQTT_IN_OUT.clientFB 的 ENABLE 参数是否为 TRUE，若不满足则退出发布流程。
4. 调用 MQTT_IN_OUT.clientFB 发布功能，传入初始化的 Topic、Payload 和 QoS 参数。
5. 监控发布结果，若发布失败则记录错误状态或触发必要的错误处理逻辑。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstPublish.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstPublish
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	publisher:MQTT.MQTTPublish;
# 	doPublish: BOOL;
# 	init: BOOL;
# 	sendPayload:STRING :='testPayload';
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	publisher.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# END_IF
# publisher(
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	PayloadString:= ADR(sendPayload), 
# 	PublishAsString:= TRUE, 
# 	QoSIn:= MQTT.QoS.ExactlyOnce, 
# 	MRetain:= FALSE, 
# 	send:= doPublish);
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstSubscription.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstSubscription
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	collector:MQTT.CallbackCollector;
# 	SUB1:MQTT.MQTTSubscribe;
# 	init: BOOL;
# 	receiver:MQTT.ReceiveString;
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	SUB1.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# 	collector.put(instance:= receiver);
# 	receiver.initAsFindTopic(compString:= ADR('TestTopic/FromCodesys'), returnHit:= TRUE);
# END_IF
# 
# SUB1(
# 	Subscribe:= TRUE, 
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	QoSSubscribe:= MQTT.QoS.ExactlyOnce, 
# 	ExpectingString:= TRUE, 
# 	Callback:= collector);
# 
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstSubscription.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstSubscription
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	collector:MQTT.CallbackCollector;
# 	SUB1:MQTT.MQTTSubscribe;
# 	init: BOOL;
# 	receiver:MQTT.ReceiveString;
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	SUB1.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# 	collector.put(instance:= receiver);
# 	receiver.initAsFindTopic(compString:= ADR('TestTopic/FromCodesys'), returnHit:= TRUE);
# END_IF
# 
# SUB1(
# 	Subscribe:= TRUE, 
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	QoSSubscribe:= MQTT.QoS.ExactlyOnce, 
# 	ExpectingString:= TRUE, 
# 	Callback:= collector);
# 	
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-PRG\HowTo.st
# --------------------------------------------------
# PROGRAM HowTo
# VAR
# 	MQTT_IN_OUT:MQTT.MQTT_IN_OUT;
# 	//HandleMQTT:SD_MQTT.HANDLE_MQTT;
# 	FirstPublish:FirstPublish;
# 	FirstSubscription:FirstSubscription;
# END_VAR
# 
# MQTT_IN_OUT.clientFB(
# 	MQTT_IN_OUT:= MQTT_IN_OUT, 
# 	ENABLE:= TRUE, 
# 	URL:= 'test.mosquitto.org:1883', 
# 	TIMEOUT:= T#2S, 
# 	TLS:= FALSE);
# 	
# FirstPublish();
# FirstSubscription();
# --------------------------------------------------


FUNCTION_BLOCK FirstPublish
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
```