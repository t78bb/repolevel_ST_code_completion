This is the known requirement information for the function to be completed:
This code is intended to implement an MQTT subscription mechanism that subscribes to a specific topic with a callback collector for processing received messages.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:
1. 初始化订阅所需的 MQTT 客户端实例，确保与 MQTT_IN_OUT.clientFB 调用的配置保持一致。
2. 设置需要订阅的 MQTT Topic，以及消息回调处理机制。
3. 调用 MQTT 客户端的订阅接口以激活订阅，提供 Topic 和回调函数。
4. 在收到消息时，通过回调函数处理并存储接收的消息内容以供后续使用。
5. 监控订阅状态，处理因网络等原因导致的订阅失败场景并重新尝试订阅。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstSubscription.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstSubscription
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	collector:MQTT.CallbackCollector;
# 	SUB1:MQTT.MQTTSubscribe;
# 	init: BOOL;
# 	receiver:MQTT.ReceiveString;
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	SUB1.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# 	collector.put(instance:= receiver);
# 	receiver.initAsFindTopic(compString:= ADR('TestTopic/FromCodesys'), returnHit:= TRUE);
# END_IF
# 
# SUB1(
# 	Subscribe:= TRUE, 
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	QoSSubscribe:= MQTT.QoS.ExactlyOnce, 
# 	ExpectingString:= TRUE, 
# 	Callback:= collector);
# 
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstSubscription.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstSubscription
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	collector:MQTT.CallbackCollector;
# 	SUB1:MQTT.MQTTSubscribe;
# 	init: BOOL;
# 	receiver:MQTT.ReceiveString;
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	SUB1.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# 	collector.put(instance:= receiver);
# 	receiver.initAsFindTopic(compString:= ADR('TestTopic/FromCodesys'), returnHit:= TRUE);
# END_IF
# 
# SUB1(
# 	Subscribe:= TRUE, 
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	QoSSubscribe:= MQTT.QoS.ExactlyOnce, 
# 	ExpectingString:= TRUE, 
# 	Callback:= collector);
# 	
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-FUN\FirstPublish.st
# --------------------------------------------------
# FUNCTION_BLOCK FirstPublish
# VAR_INPUT
# END_VAR
# VAR_OUTPUT
# END_VAR
# VAR
# 	publisher:MQTT.MQTTPublish;
# 	doPublish: BOOL;
# 	init: BOOL;
# 	sendPayload:STRING :='testPayload';
# END_VAR
# 
# IF NOT init THEN
# 	init := TRUE;
# 	publisher.SetMqttInOut(MQTT_IN_OUT:= HowTo.MQTT_IN_OUT);
# END_IF
# publisher(
# 	Topic:= ADR('TestTopic/FromCodesys'), 
# 	PayloadString:= ADR(sendPayload), 
# 	PublishAsString:= TRUE, 
# 	QoSIn:= MQTT.QoS.ExactlyOnce, 
# 	MRetain:= FALSE, 
# 	send:= doPublish);
# --------------------------------------------------
# the below code fragment can be found in:
# Interation_HowTo-PRG\HowTo.st
# --------------------------------------------------
# PROGRAM HowTo
# VAR
# 	MQTT_IN_OUT:MQTT.MQTT_IN_OUT;
# 	//HandleMQTT:SD_MQTT.HANDLE_MQTT;
# 	FirstPublish:FirstPublish;
# 	FirstSubscription:FirstSubscription;
# END_VAR
# 
# MQTT_IN_OUT.clientFB(
# 	MQTT_IN_OUT:= MQTT_IN_OUT, 
# 	ENABLE:= TRUE, 
# 	URL:= 'test.mosquitto.org:1883', 
# 	TIMEOUT:= T#2S, 
# 	TLS:= FALSE);
# 	
# FirstPublish();
# FirstSubscription();
# --------------------------------------------------


FUNCTION_BLOCK FirstSubscription
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
```