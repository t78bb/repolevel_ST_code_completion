[["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME;\n\tlastPV: REAL := 140;\n\tA: REAL;\n\tB: REAL;\n\tdelta_t: REAL;\n\tSampleTimeSec: REAL;\n\tDeadTimeIndex: INT;\n\tDelayQueue: ARRAY[0..99] OF REAL; // Circular buffer for delay\n\tQueueHead: INT := 0;\n\tQueueTail: INT := 0;\n\tQueueSize: INT := 100;\n\tQueueCount: INT := 0;\n\tDelayedCO: REAL := 0.0;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\tdelta_t := TIME_TO_REAL(Sample_time) / millis;\n\tSampleTimeSec := delta_t;\n\n\tIF Dead_t <= SampleTimeSec THEN\n\t\tDelayedCO := CO; // Skip delay if Dead_t is less than or equal to Sample_time\n\tELSE\n\t\tDeadTimeIndex := REAL_TO_INT(Dead_t / SampleTimeSec);\n\t\t\n\t\t// Store CO in delay queue\n\t\tDelayQueue[QueueHead] := CO;\n\t\tQueueHead := (QueueHead + 1) MOD QueueSize;\n\t\tIF QueueCount < QueueSize THEN\n\t\t\tQueueCount := QueueCount + 1;\n\t\tELSE\n\t\t\tQueueTail := (QueueTail + 1) MOD QueueSize;\n\t\tEND_IF;\n\n\t\t// Retrieve delayed CO from queue\n\t\tIF QueueCount > DeadTimeIndex THEN\n\t\t\tDelayedCO := DelayQueue[(QueueTail + DeadTimeIndex) MOD QueueSize];\n\t\tELSE\n\t\t\tDelayedCO := 0.0; // Default value if delay queue is not yet filled\n\t\tEND_IF;\n\tEND_IF;\n\n\tA := EXP(-delta_t / Tp);\n\tB := 1 - A;\n\n\tPV := A * lastPV + B * Kp * DelayedCO + C;\n\tlastPV := PV;\n\tlastTime := now;\nEND_IF;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0s;\n\tdelta_t: REAL;\n\theat_flow: REAL;\n\tlastTemp: REAL;\n\ttemp_diff: REAL;\n\ttemp_change_rate: REAL;\n\ttemp_change: REAL;\nEND_VAR\n\nVAR CONSTANT\n\tmillis: REAL := 1000;\nEND_VAR\n\nnow := TIME();\nIF ((now - lastTime) > Sample_time) THEN\n\t// Step 1: Calculate temperature difference\n\ttemp_diff := Temp_Out - Temp_In;\n\n\t// Step 2: Calculate heat transfer rate\n\theat_flow := Heat_In - (U * temp_diff);\n\n\t// Step 3: Calculate temperature change rate\n\tdelta_t := REAL_TO_REAL(Sample_time) / millis;\n\ttemp_change_rate := heat_flow / TC;\n\n\t// Step 4: Calculate temperature change for the current sampling period\n\ttemp_change := temp_change_rate * delta_t;\n\n\t// Step 5: Update room temperature\n\tTemp := Temp_In + temp_change;\n\n\t// Update lastTime and lastTemp\n\tlastTime := now;\n\tlastTemp := Temp;\nEND_IF;\n```"], ["```\nVAR\n    e: REAL; // Error\n    deltaPV: REAL; // Change in process variable\n    SampleTimeSec: REAL; // Sample time in seconds\n    CO_temp: REAL; // Temporary control output\nEND_VAR\n\n// Convert SampleTime from TIME to seconds\nSampleTimeSec := REAL_TO_TIME(SampleTime) / millis;\n\n// Step 1: Calculate error\ne := SP - PV;\n\n// Step 2: Calculate proportional term\nCO_P := Kc * e;\n\n// Step 3: Update and limit integral term\nCO_I := CO_I + (Kc * e * (SampleTimeSec / Ti));\nIF CO_I > UpperLimit THEN\n    CO_I := UpperLimit;\nELSIF CO_I < LowerLimit THEN\n    CO_I := LowerLimit;\nEND_IF\n\n// Step 4: Calculate derivative term\ndeltaPV := PV - lastTime;\nCO_D := -Kc * Td * (deltaPV / SampleTimeSec);\n\n// Step 5: Calculate total control output and limit it\nCO_temp := CO_P + CO_I + CO_D;\nIF CO_temp > UpperLimit THEN\n    CO := UpperLimit;\nELSIF CO_temp < LowerLimit THEN\n    CO := LowerLimit;\nELSE\n    CO := CO_temp;\nEND_IF\n\n// Step 6: Save current PV for next cycle\nlastTime := PV;\n```"], ["```\nVAR\n\tnow: TIME;\n\tlastTime: TIME := T#0ms;\n\ttimeDelta: REAL;\n\tvolumeIn: REAL;\n\tvolumeOut: REAL;\nBEGIN\n\t// Step 1: Calculate time delta in seconds\n\tnow := TIME();\n\ttimeDelta := TIME_TO_REAL(now - lastTime) / 1000.0;\n\n\t// Step 2: Calculate volume change due to input flow\n\tvolumeIn := timeDelta * Process_In;\n\n\t// Step 3: Calculate volume change due to output flow\n\tvolumeOut := timeDelta * Process_Out;\n\n\t// Step 4: Update tank level\n\tLevel := Level + volumeIn - volumeOut;\n\n\t// Step 5: Constrain tank level within limits\n\tIF Level < Lower_limit THEN\n\t\tLevel := Lower_limit;\n\tELSIF Level > Upper_limit THEN\n\t\tLevel := Upper_limit;\n\tEND_IF;\n\n\t// Update lastTime for the next cycle\n\tlastTime := now;\nEND_VAR\n```"]]