你是 IEC 61131-3 / CODESYS ST 领域的高级架构师，现在需要为一个函数块/函数编写**实现步骤规划**，帮助后续代码生成更贴近真实 ground truth。

==================== 基本信息 ====================
- 项目名称: PID_controller
- 函数类型: function_block
- 函数名: PID_controller

==================== 需求说明（requirement） ====================
This code is intended to implement a PID (Proportional-Integral-Derivative) controller for process control with configurable parameters, output limits, and anti-windup mechanisms.

==================== 已有声明部分====================
```st
//***************************************************************
//* A simple PID controller for Codesys.
//* by Alexander Jaworowski
//* Inspiration from https://github.com/br3ttb/Arduino-PID-Library
//* https://github.com/alexjaw/PID_controller
//* This Library is licensed under a MIT License
//
// 2015-02-22	Bug fix in the calculation of CO_I.
//				Added derivative term (d(err)/dt = -d(PV)/dt, i.e.
//				derivative on measurements
//***************************************************************
FUNCTION_BLOCK PID_controller
VAR_INPUT
	SP : REAL;
	PV : REAL;
	Kc : REAL;
	Ti : REAL;
	Td : REAL;
	SampleTime: TIME; //Should be ~0.1 * Tp, Tp : the process time [http://www.controlguru.com/2007/012807.html]
	LowerLimit: REAL;
	UpperLimit: REAL;
END_VAR
VAR_OUTPUT
	CO: REAL; //Controller Output
	CO_P: REAL; //Prportional term
	CO_I: REAL; //Integral term
	CO_D: REAL; //Derivative term
END_VAR
VAR CONSTANT
	millis: UINT := 1000;
END_VAR
```

==================== 调用上下文窗口（来自项目代码） ====================
【上下文片段 1】
- 文件: project_code\PID_controller\PRG\Test_PID.st
- 行号: 12
- 类型: call
```st
VAR
	PID_0: PID_controller;
	RedBull: Tank;
	Process_out: REAL := 100;
	SetPoint: REAL := 250;
END_VAR

VAR CONSTANT
END_VAR

PID_0(
    SP := SetPoint,                // 设定值：目标液位250
    PV := RedBull.Level,              // 过程值：储罐当前液位（反馈）
    Kc := 2,                  // 比例增益2.0
    Ti := 15,                  // 积分时间15.0
    Td := 1,                  // 微分时间1.0
    SampleTime := T#100ms,  // 采样时间100ms
    LowerLimit := 0,  // 输出下限0
    UpperLimit := 150,  // 输出上限150
    CO => ,                  // PID输出：控制储罐的输入流量
    CO_P => ,                      // 比例部分输出（未使用可留空）
```

【上下文片段 2】
- 文件: project_code\PID_controller\PRG\Test_PID_Heat2.st
- 行号: 9
- 类型: call
```st
PROGRAM Test_PID_Heat2
VAR
	PID_controller_0: PID_controller;
	HeatExchanger2_0: HeatExchanger2;
	SP: REAL := 300;
	Temp_out: REAL := 270;
END_VAR

PID_controller_0(
    SP := SP,                // 设定值：目标液位250
    PV := HeatExchanger2_0.Temp,              // 过程值：储罐当前液位（反馈）
    Kc := 50,                  // 比例增益2.0
    Ti := 5,                  // 积分时间15.0
    Td := 0,                  // 微分时间1.0
    SampleTime := T#250ms,  // 采样时间100ms
    LowerLimit := 0,  // 输出下限0
    UpperLimit := 6000,  // 输出上限150
    CO => ,                  // PID输出：控制储罐的输入流量
    CO_P => ,                      // 比例部分输出（未使用可留空）
```

【上下文片段 3】
- 文件: project_code\PID_controller\PRG\Test_PID_Heatx.st
- 行号: 12
- 类型: call
```st
VAR
	PID_0: PID_controller;
	Process_out: REAL := 100;
	SetPoint: REAL := 20;
	A_room_with_a_view: HeatExchanger;
END_VAR

VAR CONSTANT
END_VAR

PID_0(
    SP := SetPoint,
    PV := A_room_with_a_view.PV,
    Kc := 5.0,
    Ti := 10.0,
    Td := 1.0,
    SampleTime := T#2000ms,
    LowerLimit := 0,
    UpperLimit := 150,
    CO => ,  // 若不需要单独使用 CO 等输出，可留空，或根据需求定义变量接收
    CO_P => ,
```

==================== 核心编写规则（必须严格遵守） ====================
1. 步骤仅聚焦函数 / 函数块的核心执行逻辑，不包含：
- 额外的 “约束和假设”“无状态特性” 等非执行步骤内容；
- 对调用场景的冗余描述（如 “提供给主程序用于显示” 这类无执行意义的内容）；
- 重复的校验逻辑（如已校验非负则无需再提 “强制设为零” 之外的解释）。
2. 每一步仅描述一个独立的操作 / 逻辑，语言简洁、无修饰，直接说明 “做什么”；
3. 步骤中引用的变量名、类型必须与声明部分 / 调用上下文完全一致；
4. 步骤数量控制在 3-6 步，仅保留核心逻辑，剔除所有非必要的补充说明。

==================== 你的任务 ====================
1. 基于上述需求、声明和调用上下文，推断该函数块/函数在整个项目中的职责、输入输出意义以及与其他模块的交互关系。
2. 给出一个**分步骤的功能规划/设计说明**，每一步都要尽量贴近调用场景。
3. 规划结果要适合后续直接转换为 ST 实现代码，注意：
   - 不要给出具体 ST 代码，只写步骤/逻辑。
   - 引用调用上下文中的变量名、调用方式，保持语义一致。
   - 如果发现调用方式隐含了某些约束（例如只在某些状态下调用），在规划里明确写出。

==================== 输出格式要求 ====================
请严格使用如下中文结构化格式输出（不要添加多余解释）：

功能规划:
1. ...
2. ...
3. ...
N. ...