[["```\nVAR\n    LeftClickTimer : TON;\n    xLeftClickOld : BOOL;\n    iClickCount : INT := 0;\n    xEventProcessed : BOOL := FALSE;\n    rLastMouseX : REAL := 0.0;\n    rLastMouseY : REAL := 0.0;\nEND_VAR\n\n(* Reset event state *)\neMouseEvent := 0;\nxEventActive := FALSE;\n\n(* Handle left click events (single/double click) *)\nIF xLeftClick AND NOT xLeftClickOld THEN\n    (* First click detected *)\n    IF iClickCount = 0 THEN\n        LeftClickTimer(IN := TRUE, PT := tDblClickTime);\n        iClickCount := 1;\n    ELSE\n        (* Second click within time window *)\n        LeftClickTimer(IN := FALSE);\n        eMouseEvent := 2; (* Double click *)\n        rEventX := rMouseX;\n        rEventY := rMouseY;\n        xEventActive := TRUE;\n        iClickCount := 0;\n        xEventProcessed := TRUE;\n    END_IF\nELSIF NOT xLeftClick AND xLeftClickOld THEN\n    (* Left button released *)\n    IF iClickCount = 1 AND NOT xEventProcessed THEN\n        LeftClickTimer();\n        IF NOT LeftClickTimer.Q THEN\n            (* Still waiting for potential double click *)\n        ELSE\n            (* Timeout, register single click *)\n            eMouseEvent := 1; (* Single click *)\n            rEventX := rMouseX;\n            rEventY := rMouseY;\n            xEventActive := TRUE;\n            iClickCount := 0;\n        END_IF\n    END_IF\nEND_IF\n\n(* Check for double click timeout *)\nIF LeftClickTimer.Q AND iClickCount = 1 THEN\n    (* Timeout, register single click *)\n    eMouseEvent := 1; (* Single click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    iClickCount := 0;\nEND_IF\n\n(* Handle right click events *)\nIF xRightClick THEN\n    eMouseEvent := 3; (* Right click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\nEND_IF\n\n(* Handle middle click events *)\nIF xMiddleClick THEN\n    eMouseEvent := 4; (* Middle click *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\nEND_IF\n\n(* Handle mouse movement events *)\nIF xMouseMove AND (rMouseX <> rLastMouseX OR rMouseY <> rLastMouseY) THEN\n    eMouseEvent := 0; (* Mouse move *)\n    rEventX := rMouseX;\n    rEventY := rMouseY;\n    xEventActive := TRUE;\n    rLastMouseX := rMouseX;\n    rLastMouseY := rMouseY;\nEND_IF\n\n(* Update old state *)\nxLeftClickOld := xLeftClick;\n```"], ["```\nVAR\n    NodeDblClick : TON; (* Timer for detecting double click *)\n    xNodeClickOld : BOOL; (* Previous state of the click input *)\n    iNodeState : INT := 1; (* State machine variable *)\nEND_VAR\n\nCASE iNodeState OF\n\n    1: (* Wait for first click *)\n        IF xNodeClick AND NOT xNodeClickOld THEN\n            NodeDblClick(IN := TRUE, PT := tDblClickTime);\n            iNodeState := 2;\n            xNodeSelected := TRUE;\n        END_IF\n\n    2: (* Wait for second click or timeout *)\n        NodeDblClick();\n        IF NodeDblClick.Q THEN\n            (* Timeout - single click, reset *)\n            NodeDblClick(IN := FALSE);\n            xNodeClickOld := FALSE;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        ELSIF NOT xNodeClick AND xNodeClickOld THEN\n            (* Second click detected - toggle expansion *)\n            NodeDblClick(IN := FALSE);\n            xNodeExpand := NOT xNodeExpand;\n            iNodeState := 1;\n            xNodeSelected := FALSE;\n        END_IF\n\nEND_CASE\n\nxNodeClickOld := xNodeClick;\n```"], ["```\nVAR\n    rRadians : REAL;\n    rCos : REAL;\n    rSin : REAL;\n    rTranslatedX : REAL;\n    rTranslatedY : REAL;\nEND_VAR\n\nrRadians := rAngle * PI / 180.0; (* Convert angle from degrees to radians *)\nrCos := COS(rRadians);          (* Calculate cosine of the angle *)\nrSin := SIN(rRadians);          (* Calculate sine of the angle *)\n\nrTranslatedX := rPointX - rCenterX; (* Calculate relative X coordinate *)\nrTranslatedY := rPointY - rCenterY; (* Calculate relative Y coordinate *)\n\nrRotatedX := (rTranslatedX * rCos) - (rTranslatedY * rSin) + rCenterX; (* Calculate rotated X coordinate *)\nrRotatedY := (rTranslatedX * rSin) + (rTranslatedY * rCos) + rCenterY; (* Calculate rotated Y coordinate *)\n\nRETURN TRUE; (* Return success status *)\n```"]]