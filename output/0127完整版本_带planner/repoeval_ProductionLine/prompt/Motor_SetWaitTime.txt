This is the known requirement information for the function to be completed:
This code is intended to implement a mechanism for setting a wait time for a motor operation using a specified sequence delay.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:  
1. 检查输入参数 `SequenceDelay` 是否为有效时间值（非负时间）。  
2. 使用 `SequenceDelay` 更新 `MotorI.WaitTime` 属性或相关字段。  
3. 将更新后的 `MotorI` 值复制到 `MotorO`，确保输出包含变更后的状态。  
4. 返回方法执行成功标志 `TRUE` 作为输出。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_SetWaitTime.st
# --------------------------------------------------
# METHOD SetWaitTime : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# 	SequenceDelay:TIME;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# InternalSequenceDelay:=SequenceDelay;
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_SetFault.st
# --------------------------------------------------
# METHOD SetFault : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# IF MotorI.Overload THEN
# 	MotorO.FaultStatus:=TRUE;
# 	TurnOff();
# END_IF
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor.st
# --------------------------------------------------
# FUNCTION_BLOCK Motor
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# 
# SetFault();
# ResetFault();
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_TurnOff.st
# --------------------------------------------------
# METHOD TurnOff : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# MotorO.Coil:=false;
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_TurnOn.st
# --------------------------------------------------
# METHOD TurnOn : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# IF MotorO.FaultStatus = FALSE THEN
# 	WaitTimer(IN:=TRUE , PT:=InternalSequenceDelay);
# END_IF
# 
# IF WaitTimer.Q THEN
# 	MotorO.Coil:=TRUE;
# 	WaitTimer(IN:=FALSE);
# END_IF
# --------------------------------------------------


METHOD SetWaitTime : BOOL
VAR_INPUT
	MotorI:MotorI;
	SequenceDelay:TIME;
END_VAR
VAR_OUTPUT
	MotorO:MotorO;
END_VAR
```