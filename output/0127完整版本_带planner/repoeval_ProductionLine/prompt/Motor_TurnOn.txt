This is the known requirement information for the function to be completed:
This code is intended to implement a mechanism to turn on a motor by activating its coil after a specified delay, provided there is no fault status.
This provides you with a plan of implementation steps for the function to be completed. Subsequent ST code must strictly follow this plan and must not deviate from the core logic. The following is the plan of implementation steps:
功能规划:  
1. 检查输入的 `MotorI.FaultStatus` 是否为 TRUE，若为 TRUE，则直接结束方法并返回 FALSE。  
2. 检查是否达到指定的延时时间 `MotorI.DelayTime`，若未达到，则直接结束方法并返回 FALSE。  
3. 激活 `MotorO.Coil` 控制信号，将其设置为 TRUE。  
4. 返回 TRUE，表示电机已成功开启。
Continue writing the following code:

```
# Here are some relevant code fragments from other files of the repo:
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_TurnOn.st
# --------------------------------------------------
# METHOD TurnOn : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# IF MotorO.FaultStatus = FALSE THEN
# 	WaitTimer(IN:=TRUE , PT:=InternalSequenceDelay);
# END_IF
# 
# IF WaitTimer.Q THEN
# 	MotorO.Coil:=TRUE;
# 	WaitTimer(IN:=FALSE);
# END_IF
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_TurnOff.st
# --------------------------------------------------
# METHOD TurnOff : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# MotorO.Coil:=false;
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_SetFault.st
# --------------------------------------------------
# METHOD SetFault : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# IF MotorI.Overload THEN
# 	MotorO.FaultStatus:=TRUE;
# 	TurnOff();
# END_IF
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor.st
# --------------------------------------------------
# FUNCTION_BLOCK Motor
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# END_VAR
# 
# 
# SetFault();
# ResetFault();
# --------------------------------------------------
# the below code fragment can be found in:
# ProductionLine-FUN\Motor_ResetFault.st
# --------------------------------------------------
# METHOD ResetFault : BOOL
# VAR_INPUT
# 	MotorI:MotorI;
# END_VAR
# VAR_OUTPUT
# 	MotorO:MotorO;
# END_VAR
# VAR
# 	WaitTimer:TON;
# 	InternalSequenceDelay:time;
# 	ResetDetect:r_trig;
# END_VAR
# 
# ResetDetect(CLK:=MotorI.FaultReset);
# 
# IF ResetDetect.Q THEN
# 	MotorO.FaultStatus:=FALSE;
# END_IF
# --------------------------------------------------


METHOD TurnOn : BOOL
VAR_INPUT
	MotorI:MotorI;
END_VAR
VAR_OUTPUT
	MotorO:MotorO;
END_VAR
```