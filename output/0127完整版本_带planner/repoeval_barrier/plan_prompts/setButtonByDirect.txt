你是 IEC 61131-3 / CODESYS ST 领域的高级架构师，现在需要为一个函数块/函数编写**实现步骤规划**，帮助后续代码生成更贴近真实 ground truth。

==================== 基本信息 ====================
- 项目名称: barrier
- 函数类型: function
- 函数名: setButtonByDirect

==================== 需求说明（requirement） ====================
This code is intended to implement the control of UI button states for ground and sky tracks based on input parameters for level, index, and direction.

==================== 已有声明部分====================
```st
FUNCTION setButtonByDirect : BOOL
VAR_INPUT
	level		:INT;	//1->地轨	2->天轨
	idx			:INT;	//挡板索引编号
	direct		:TargetDirect;
END_VAR
```

==================== 调用上下文窗口（来自项目代码） ====================
【上下文片段 1】
- 文件: project_code\barrier\PRG\Barrier_autoReseButton.st
- 行号: 4
- 类型: call
```st
//更新Button
FOR gi := 1 TO 10 DO
	setButtonByDirect(1, gi, gDev.grd[gi].vector);
END_FOR


FOR si := 0 TO 10 DO
	setButtonByDirect(2, si, gDev.sky[si].vector);
END_FOR
```

【上下文片段 2】
- 文件: project_code\barrier\PRG\Barrier_autoReseButton.st
- 行号: 9
- 类型: call
```st
//更新Button
FOR gi := 1 TO 10 DO
	setButtonByDirect(1, gi, gDev.grd[gi].vector);
END_FOR


FOR si := 0 TO 10 DO
	setButtonByDirect(2, si, gDev.sky[si].vector);
END_FOR
```

【上下文片段 3】
- 文件: project_code\barrier\PRG\Barrier_interfaceAct.st
- 行号: 42
- 类型: call
```st
ELSE
		IF gUI.grd[gi].btnExtend THEN
			//伸缩指令不能同时发出，检测到后进行动作转换，重置计数器
			gDev.grd[gi].timeCounter := 0;
			gDev.grd[gi].exeCounter := 0;
			IF gUI.grd[gi].btnLast = TargetDirect.retract THEN
				gDev.grd[gi].vector := TargetDirect.extend;
			ELSE
				gDev.grd[gi].vector := TargetDirect.retract;
			END_IF
			setButtonByDirect(1, gi, gDev.grd[gi].vector);
		ELSE
			gDev.grd[gi].vector := TargetDirect.stop;	
		END_IF
	END_IF
	IF gUI.grd[gi].btnStop THEN
		gDev.grd[gi].vector := TargetDirect.stop;
		setButtonByDirect(1, gi, gDev.grd[gi].vector);
	END_IF
END_FOR
```

【上下文片段 4】
- 文件: project_code\barrier\PRG\Barrier_interfaceAct.st
- 行号: 49
- 类型: call
```st
ELSE
				gDev.grd[gi].vector := TargetDirect.retract;
			END_IF
			setButtonByDirect(1, gi, gDev.grd[gi].vector);
		ELSE
			gDev.grd[gi].vector := TargetDirect.stop;	
		END_IF
	END_IF
	IF gUI.grd[gi].btnStop THEN
		gDev.grd[gi].vector := TargetDirect.stop;
		setButtonByDirect(1, gi, gDev.grd[gi].vector);
	END_IF
END_FOR

FOR si := 0 TO 10 DO
	IF gUI.sky[si].btnExtend <> gUI.sky[si].btnRetract THEN
		gDev.sky[si].state := DevStatus.runing;
		IF gUI.sky[si].btnExtend THEN
			gDev.sky[si].vector := TargetDirect.extend;
			gUI.sky[si].btnLast := TargetDirect.extend;
		END_IF
```

【上下文片段 5】
- 文件: project_code\barrier\PRG\Barrier_interfaceAct.st
- 行号: 74
- 类型: call
```st
ELSE
		IF gUI.sky[si].btnExtend THEN
			//伸缩指令不能同时发出，检测到后进行动作转换，重置计数器
			gDev.sky[si].timeCounter := 0;
			gDev.sky[si].exeCounter := 0;
			IF gUI.sky[si].btnLast = TargetDirect.retract THEN
				gDev.sky[si].vector := TargetDirect.extend;
			ELSE
				gDev.sky[si].vector := TargetDirect.retract;
			END_IF
			setButtonByDirect(2, si, gDev.sky[si].vector);
		ELSE
			gDev.sky[si].vector := TargetDirect.stop;
		END_IF
	END_IF
	IF gUI.sky[si].btnStop THEN
		gDev.sky[si].vector := TargetDirect.stop;
		setButtonByDirect(1, gi, gDev.grd[gi].vector);
	END_IF
END_FOR
```

【上下文片段 6】
- 文件: project_code\barrier\PRG\Barrier_interfaceAct.st
- 行号: 81
- 类型: call
```st
ELSE
				gDev.sky[si].vector := TargetDirect.retract;
			END_IF
			setButtonByDirect(2, si, gDev.sky[si].vector);
		ELSE
			gDev.sky[si].vector := TargetDirect.stop;
		END_IF
	END_IF
	IF gUI.sky[si].btnStop THEN
		gDev.sky[si].vector := TargetDirect.stop;
		setButtonByDirect(1, gi, gDev.grd[gi].vector);
	END_IF
END_FOR
```

【上下文片段 7】
- 文件: project_code\barrier\PRG\ModbusAct_localCmdHandler.st
- 行号: 46
- 类型: call
```st
IF gModbus.srv.request.arrNew[iSec, iBit] <> gModbus.srv.request.arrLast[iSec, iBit] THEN
			IF gModbus.srv.request.arrNew[iSec, iBit] THEN	//仅执行上升沿
				//specifically output[grd/sky(exLevel), no(exIdx), TargetDirect(exDirect)]
				l2p(section := iSec, lgcIdx := iBit, 
					level => exLevel, phyIdx => exIdx, direct => exDirect);
				exeDirect := rvs.cmdReverse(input := exDirect);		//华中要求伸缩指令及状态翻转
				
				//过滤	机械结构未完成的grd[4] and sky[4]
				IF exIdx = 4 THEN	exeDirect := TargetDirect.stop;	END_IF
				
				setButtonByDirect(level := exLevel, idx := exIdx, direct := exeDirect);
			END_IF
			gModbus.srv.request.arrLast[iSec, iBit] := gModbus.srv.request.arrNew[iSec, iBit];			
		END_IF
	END_FOR
	
END_FOR


devNum := gModbus.modbusBuffer[49];
```

==================== 核心编写规则（必须严格遵守） ====================
1. 步骤仅聚焦函数 / 函数块的核心执行逻辑，不包含：
- 额外的 “约束和假设”“无状态特性” 等非执行步骤内容；
- 对调用场景的冗余描述（如 “提供给主程序用于显示” 这类无执行意义的内容）；
- 重复的校验逻辑（如已校验非负则无需再提 “强制设为零” 之外的解释）。
2. 每一步仅描述一个独立的操作 / 逻辑，语言简洁、无修饰，直接说明 “做什么”；
3. 步骤中引用的变量名、类型必须与声明部分 / 调用上下文完全一致；
4. 步骤数量控制在 3-6 步，仅保留核心逻辑，剔除所有非必要的补充说明。

==================== 你的任务 ====================
1. 基于上述需求、声明和调用上下文，推断该函数块/函数在整个项目中的职责、输入输出意义以及与其他模块的交互关系。
2. 给出一个**分步骤的功能规划/设计说明**，每一步都要尽量贴近调用场景。
3. 规划结果要适合后续直接转换为 ST 实现代码，注意：
   - 不要给出具体 ST 代码，只写步骤/逻辑。
   - 引用调用上下文中的变量名、调用方式，保持语义一致。
   - 如果发现调用方式隐含了某些约束（例如只在某些状态下调用），在规划里明确写出。

==================== 输出格式要求 ====================
请严格使用如下中文结构化格式输出（不要添加多余解释）：

功能规划:
1. ...
2. ...
3. ...
N. ...