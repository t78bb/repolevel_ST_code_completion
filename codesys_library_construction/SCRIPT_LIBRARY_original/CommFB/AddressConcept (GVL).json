{
  "library": "CommFB",
  "title": "AddressConcept (GVL)",
  "url": "https://content.helpme-codesys.com/en/libs/CommFB/Current/CommFB/AddressConcept.html#",
  "page_title": "AddressConcept (GVL)",
  "text": "CommFB\nAINFO_TYPE (Union)\nAddressConcept (GVL)\nAddress Concept\nGenerating a CommFB-ID\nProfibus DP\nProfinet IO\nDevice Diagnosis\nAddress Conversion\nAddresses\nADDR_TO_ID (FunctionBlock)\nADDR_TYPE (Union)\nCREATE_ID (FunctionBlock)\nDP_ADDR (Struct)\nDP_DEVICE_ID (Struct)\nID_TO_ADDR (FunctionBlock)\nIO_SYSTEM_TYPE (Enum)\nPN_ADDR (Struct)\nPN_DEVICE_ID (Struct)\nSUBSLOT_ID (Function)\nCNCT (FunctionBlock)\nConstants (GVL)\nDP Address\nADDR (Function)\nID (Function)\nSLOT_ID (Function)\nDP_AINFO (Struct)\nDP_DIAG (Struct)\nErrorCode (Enum)\nErrorCode1_RW (Enum)\nFieldDevice\nPRVREC (FunctionBlock)\nPRVREC_MODE (Enum)\nRCVREC (FunctionBlock)\nRCVREC_MODE (Enum)\nSALARM (FunctionBlock)\nGETIO_PART (FunctionBlock)\nPN_AINFO (Struct)\nRALARM (FunctionBlock)\nRALARM_MODE (Enum)\nRDIAG (FunctionBlock)\nRDREC (FunctionBlock)\nSETIO_PART (FunctionBlock)\nWRREC (FunctionBlock)\nImages\nLibrary Information\nGetLibVersion (Function)\nGetLibVersionNumber (Function)\nIsLibReleased (Function)\nFile and Project Information\nLibrary Reference\nIoDriver Profibus2 Interfaces\nLibrary Identification\nLibrary Properties\nSysMem\nLibrary Identification\nLibrary Properties\nCommFB\nDocs\n»\nCommFB\n»\nAddressConcept (GVL)\nAddressConcept (GVL)\nÂ¶\nAddress Concept\nÂ¶\nIO Systems like PROFIBUS DP and PROFINET IO use different address concepts.\nThis results in different functions or function parameters to identify a Field Device, a slot or subslot inside a Field Device.\nIn order to provide an uniform interface for the use with different types of IO communication subsystems, all Communication Function Blocks hide the address concept of the specific IO Systems.\nThe Function Blocks use an abstract ââIDââ, a handle of data type DWORD, to uniquely identify a Profibus-Module or a Profinet-Submodule within an application.\nTherefore an application program is able to use the Communication Function Blocks without knowledge of the explicit hardware configuration (e.g. the MAC address or Station-Name of a Field Device or the slot-position of a module).\nThis way an application or library can be developed without dependencies to hardware configuration data such as a specific IO-Driver or an addressing method.\nGenerating a CommFB-ID\nÂ¶\nThere are different methods, generic and more specific ones, to generate an ID for identifying a Profibus/Profinet device:\nNote\nThe actual value of ID should never be manipulated or created,\nonly use the IDs created from theses sources described here.\nThe value of ID can differ depending on the project structure or the driver version !\nProfibus DP\nÂ¶\nThe input parameter ID of the Communication Function Blocks addresses one slot of a DP-slave or a DP-slave (Slot 0).\nThis handle may be generated by using one of the following functions:\nID\n: Conversion of a physical address of a DP-slave to the handle\nADDR\n: Conversion of a handle to the physical address of a DP-slave\nSLOT_ID\n: Addressing a slot of a DP-slave\nProfinet IO\nÂ¶\nThe input parameter ID of the Communication Function Blocks addresses a Profinet-Submodule.\nA Profinet Module is just a container for at least one submodule. IO-Data and Parameters are always assigned to a submodule.\nThe shortest way to get the ID of a submodule is to call the GetID()-method of the Profinet-Slave function block which is generated for each Profinet-Slave device:\nCode-Example: ID with GetID() - method\nPROGRAM\nPLC_PRG\nVAR\nID\n:\nDWORD\n:=\nCommFB.Constants.INVALID_ID\n;\nEND_VAR\nID\n:=\nPNSlave.GetID\n(\nAPI\n:=\n0\n,\nSLOT\n:=\n1\n,\nSUBSLOT\n=\n1\n);\n// get ID of 1. module\nDevice Diagnosis\nÂ¶\nA generic way for obtaining an CommFB-ID is by calling the method IDevice.GetDeviceInfo().\nFor an underlying Profinet/Profibus slave or module, the generic DEVICE_INFO structure, which is returned by this method, contains the unique CommFB-ID:\nCode-Example: ID with generic Device Diagnosis\nFUNCTION\nListStationnames\n:\nDINT\nVAR_IN_OUT\ncontroller\n:\nDED.IDevice\n;\nEND_VAR\nVAR\ni\n:\nDINT\n;\nchildDevice\n:\nDED.IDevice\n;\ndeviceInfo\n:\nDED.DEVICE_INFO\n;\nconvertID\n:\nCommFB.ID_TO_ADDR\n;\npnAddress\n:\nCommFB.ADDR_TYPE\n;\nstationName\n:\nSTRING\n;\nEND_VAR\nFOR\ni\n:=\n0\nTO\nTO_DINT\n(\ncontroller.ChildNodeCount\n-\n1\n)\nDO\nchildDevice\n:=\nDED.INode_TO_IDevice\n(\ncontroller.GetChild\n(\nTO_UDINT\n(\ni\n)));\nIF\n(\nchildDevice\n<>\n0\nAND_THEN\nchildDevice.GetDeviceInfo\n(\ndeviceInfo\n)\n=\nDED.ERROR.NO_ERROR\n)\nTHEN\nconvertID\n(\nEN\n:=\nTRUE\n,\nID\n:=\ndeviceInfo.idSystem\n,\nADDR\n:=\npnAddress\n);\nIF\n(\nconvertID.ENO\n)\nTHEN\nIF\n(\npnAddress.SYSTEM\n=\nCommFB.IO_SYSTEM_TYPE.PROFINET_IO\n)\nTHEN\n//we have a valid Profinet Address:\nstationName\n:=\npnAddress.PN.D.STATIONNAME\n;\nEND_IF\nEND_IF\nEND_IF\nEND_FOR\nAddress Conversion\nÂ¶\nFor some use cases it may be necessary to use native PROFIBUS DP and PROFINET IO addressing.\nThese function blocks can be used for obtaining an ID to a native, protocol specific address and vice versa (see examples in the function blockâs description)\nThe handle may be generated by local means of the PLC or its configuration system or may be generated by using one of the following functions:\nADDR_TO_ID\n: Conversion of a address of a PROFINET IO Device to the handle\nID_TO_ADDR\n: Conversion of a handle to the address of a PROFINET IO Device\nInOut:\nScope\nName\nType\nInitial\nConstant\ndummy\nUDINT\n0",
  "tables": [
    {
      "headers": [
        "Scope",
        "Name",
        "Type",
        "Initial"
      ],
      "rows": [
        {
          "Scope": "Constant",
          "Name": "dummy",
          "Type": "UDINT",
          "Initial": "0"
        }
      ]
    }
  ]
}