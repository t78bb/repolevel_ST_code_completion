{
  "library": "SM3_Robotics",
  "title": "SMC_CIRC_MODE (Enum)",
  "url": "https://content.helpme-codesys.com/en/libs/SM3_Robotics/Current/SM3_Robotics/Basic-types/SMC_CIRC_MODE.html",
  "page_title": "SMC_CIRC_MODE (ENUM)",
  "text": "Library Information\nGetLibVersion (Function)\nGetLibVersionNumber (Function)\nGetVersion (Function)\nIsLibReleased (Function)\nSM3_Robotics\nBasic types\nIDENT_IN_GROUP_REF_SM3 (Alias)\nMC_CIRC_PATHCHOICE (Enum)\nMC_COORD_REF (Struct)\nMC_EXECUTION_MODE (Enum)\nMC_TRANSITION_MODE (Enum)\nSMC_AXIS_GROUP_COMPATIBILITY_OPTIONS (Struct)\nSMC_AXIS_GROUP_CONTINUE_DATA (FunctionBlock)\nSMC_AXIS_GROUP_STATE (Enum)\nSMC_CIRC_MODE (Enum)\nSMC_DYN_LIMITS (Alias)\nSMC_IDynamicCS (Interface)\nSMC_ORIENTATION_MODE (Enum)\nSMC_POS_REF (Union)\nSMC_PTP_MOVEMENT_TYPE (Enum)\nSMC_READ_TOOL_MODE (Enum)\nPOUs\nAdditional\nSMC_AxisDistanceAxes (Enum)\nSMC_AxisDistanceSubMode (Enum)\nSMC_AxisDistanceTransition (FunctionBlock)\nSMC_AxisDistanceTransitionParam (Function)\nSMC_CornerDistance (FunctionBlock)\nSMC_CornerDistanceTransitionParam (Function)\nSMC_StartVelocity (FunctionBlock)\nSMC_StartVelocityAxes (Enum)\nSMC_StartVelocityTransitionParam (Function)\nSMC_StartupAxisGroup (FunctionBlock)\nAdministrative/Configuration\nAxisGroup\nComputation\nCoordinate systems\nDynamics\nKinematics\nTrigger\nAxisGroup\nAXIS_GROUP_REF_SM3 (FunctionBlock)\nHelpers\nMovements\nDiagnostics\nMC_GroupReadActualAcceleration (FunctionBlock)\nMC_GroupReadActualPosition (FunctionBlock)\nMC_GroupReadActualVelocity (FunctionBlock)\nMC_GroupReadConfiguration (FunctionBlock)\nMC_GroupReadError (FunctionBlock)\nMC_GroupReadStatus (FunctionBlock)\nMC_ReadCoordinateTransform (FunctionBlock)\nMC_ReadKinTransform (FunctionBlock)\nSMC_GroupAddOffset (FunctionBlock)\nSMC_GroupAdditionalAxesTargetPositions (FunctionBlock)\nSMC_GroupConvertPosition (FunctionBlock)\nSMC_GroupGetContinuePosition (FunctionBlock)\nSMC_GroupGetContinueToolOffset (FunctionBlock)\nSMC_GroupReadPathAcceleration (FunctionBlock)\nSMC_GroupReadPathDynamics (FunctionBlock)\nSMC_GroupReadPathVelocity (FunctionBlock)\nSMC_GroupReadPlanningStatistics (FunctionBlock)\nSMC_GroupReadPositionInMovement (FunctionBlock)\nSMC_GroupReadRemainingTrajectoryDuration (FunctionBlock)\nSMC_GroupReadSetAcceleration (FunctionBlock)\nSMC_GroupReadSetJerk (FunctionBlock)\nSMC_GroupReadSetPosition (FunctionBlock)\nSMC_GroupReadSetVelocity (FunctionBlock)\nSMC_GroupTargetPosition (FunctionBlock)\nSMC_ReadKinTransformForAxis (FunctionBlock)\nMovement\nAdditionalAxes\nGroupInterrupt\nMC_GroupContinue (FunctionBlock)\nMC_GroupHalt (FunctionBlock)\nMC_GroupInterrupt (FunctionBlock)\nMC_GroupStop (FunctionBlock)\nMC_MoveCircularAbsolute (FunctionBlock)\nMC_MoveCircularRelative (FunctionBlock)\nMC_MoveDirectAbsolute (FunctionBlock)\nMC_MoveDirectRelative (FunctionBlock)\nMC_MoveLinearAbsolute (FunctionBlock)\nMC_MoveLinearRelative (FunctionBlock)\nSMC_GroupEnableResumeAfterError (FunctionBlock)\nSMC_GroupJog (FunctionBlock)\nSMC_GroupJog2 (FunctionBlock)\nSMC_GroupUpdateContinueData (FunctionBlock)\nSMC_GroupWait (FunctionBlock)\nSMC_MoveAdditionalAxes (FunctionBlock)\ninternal\nDivers\nKernel_CP\nFile and Project Information\nLibrary Reference\n3SLicense\nLibrary Identification\nLibrary Properties\nCmpApp\nLibrary Identification\nLibrary Properties\nCmpIecTask\nLibrary Identification\nLibrary Properties\nCmpLog\nLibrary Identification\nLibrary Properties\nFloatingPointUtils\nLibrary Identification\nLibrary Properties\nSM3_Basic\nLibrary Identification\nLibrary Properties\nLibrary Parameter\nSM3_CPKernelDefaults\nLibrary Identification\nLibrary Properties\nLibrary Parameter\nSM3_CommonPublic\nLibrary Identification\nLibrary Properties\nSM3_Dynamics\nLibrary Identification\nLibrary Properties\nSM3_Error\nLibrary Identification\nLibrary Properties\nSM3_RBase\nLibrary Identification\nLibrary Properties\nSM3_RCP\nLibrary Identification\nLibrary Properties\nSM3_RError\nLibrary Identification\nLibrary Properties\nSM3_Ramps\nLibrary Identification\nLibrary Properties\nSM3_Shared\nLibrary Identification\nLibrary Properties\nSM3_StringUtils\nLibrary Identification\nLibrary Properties\nSM3_TrajectoryGeneration\nLibrary Identification\nLibrary Properties\nSM3_Transformation\nLibrary Identification\nLibrary Properties\nStandard\nLibrary Identification\nLibrary Properties\nSysMem\nLibrary Identification\nLibrary Properties\nSysTarget\nLibrary Identification\nLibrary Properties\nSysTime\nLibrary Identification\nLibrary Properties\nSysTypes2 Interfaces\nLibrary Identification\nLibrary Properties\nSM3_Robotics\nDocs\n»\nSM3_Robotics\n»\nBasic\ntypes\n»\nSMC_CIRC_MODE (ENUM)\nSMC_CIRC_MODE (ENUM)\nÂ¶\nTYPE SMC_CIRC_MODE :\nThe circ mode defines how an arc segment is described.\nSee\nMC_MoveCircularAbsolute\nand\nMC_MoveCircularRelative\n.\nAttributes:\nqualified_only\nInOut:\nName\nComment\nBORDER\nThe user defines the end point and a border point (input\nAuxPoint\n)\non the sector of the circle, which shall be cruised by the machine.\n(Input\nPathChoice\nis not considered for mode\nBORDER\n.)\nAdvantage of this mode: the border point usually can be reached by\nthe machine, i.e. it can be teached.\nInconvenience of this mode: Restriction to angles < 2Ï in one single\ncommand.\nNote\nThe three points (starting point, end point, and aux point)\nmust not be collinear.\nCENTER\nThe user defines the end point and the center point (input\nAuxPoint\n)\nof the circle.\nWhen using this mode, the input\nPathChoice\ndefines, which of\nthe two possible arcs is used.  The plane normal is the unit vector\nin the direction of (start - center) x (dest - center).\nThe direction of the arc is chosen according to the rule of right\nthumb: counter-clockwise direction is along the fingers bending around\nthe axis of the thumb which represents the normal vector.\nInconveniencies of this mode:\nRestriction to angles < 2Ï and â  Ï in one single command;\nThe center point usually cannot be teached in due to collisions\nwith obstacles.\nNote\nIf the center point is not exactly at the same distance to\nthe start- and the end-point (which is often the case due to the\nlimited precision in which the center-point is programmed), then\nit is projected onto the perpendicular bisector of start- and\nend-point.\nOnce the center-point is too far off (more than 1 percent of the\nradius), an error is returned.\nRADIUS\nThe user defines the end point and the perpendicular vector of the\ncircle plane according to the rule of right thumb:  counter-clockwise\ndirection is along the fingers bending around the axis of the thumb.\nThe normal vector is the input\nAuxPoint\n.  That is,\nAuxPoint\nis not a position but a direction vector.\nThe radius of the circle is the length of the vector.\nIf the distance between start- and end-point is not equal to the\ndiameter, there are two possible circles with the given radius.\nThe input\nPathChoice\ndefines the direction of the arc.\nThe system then chooses the circle for which the distance from\nstart- to end-point is shorter.  This means that the total angle\nwill be at most Ï.\nIf the movement is commanded in ACS-coordinates, then the auxiliary\npoint will just be transformed into MCS using the kinematic\ntransformation in order to interprete it as an MCS-direction.\nNote\nIf start- and end-point are not in the plane defined by\nthe normal vector, a helical movement from start- to end-point\nis created.  That means a circular movement in the plane plus\na linear movement orthogonal to the plane.\nInconveniences of this mode:\nRestriction to angles <= Ï in one single command;\nThe perpendicular vector has to be computed.\nExample:\nAuxPoint = (50,0,0) -> Circle in plane parallel to yz\nplane with radius 50 and rotation around axis\nparallel to x-axis according to the rule of right thumb\n(CoordSystem = MCS)",
  "tables": [
    {
      "headers": [
        "Name",
        "Comment"
      ],
      "rows": [
        {
          "Name": "BORDER",
          "Comment": "The user defines the end point and a border point (inputAuxPoint)\non the sector of the circle, which shall be cruised by the machine.(InputPathChoiceis not considered for modeBORDER.)Advantage of this mode: the border point usually can be reached by\nthe machine, i.e. it can be teached.Inconvenience of this mode: Restriction to angles < 2Ï in one single\ncommand.NoteThe three points (starting point, end point, and aux point)\nmust not be collinear."
        },
        {
          "Name": "CENTER",
          "Comment": "The user defines the end point and the center point (inputAuxPoint)\nof the circle.When using this mode, the inputPathChoicedefines, which of\nthe two possible arcs is used.  The plane normal is the unit vector\nin the direction of (start - center) x (dest - center).\nThe direction of the arc is chosen according to the rule of right\nthumb: counter-clockwise direction is along the fingers bending around\nthe axis of the thumb which represents the normal vector.Inconveniencies of this mode:Restriction to angles < 2Ï and â  Ï in one single command;The center point usually cannot be teached in due to collisions\nwith obstacles.NoteIf the center point is not exactly at the same distance to\nthe start- and the end-point (which is often the case due to the\nlimited precision in which the center-point is programmed), then\nit is projected onto the perpendicular bisector of start- and\nend-point.\nOnce the center-point is too far off (more than 1 percent of the\nradius), an error is returned."
        },
        {
          "Name": "RADIUS",
          "Comment": "The user defines the end point and the perpendicular vector of the\ncircle plane according to the rule of right thumb:  counter-clockwise\ndirection is along the fingers bending around the axis of the thumb.The normal vector is the inputAuxPoint.  That is,AuxPointis not a position but a direction vector.\nThe radius of the circle is the length of the vector.If the distance between start- and end-point is not equal to the\ndiameter, there are two possible circles with the given radius.The inputPathChoicedefines the direction of the arc.\nThe system then chooses the circle for which the distance from\nstart- to end-point is shorter.  This means that the total angle\nwill be at most Ï.If the movement is commanded in ACS-coordinates, then the auxiliary\npoint will just be transformed into MCS using the kinematic\ntransformation in order to interprete it as an MCS-direction.NoteIf start- and end-point are not in the plane defined by\nthe normal vector, a helical movement from start- to end-point\nis created.  That means a circular movement in the plane plus\na linear movement orthogonal to the plane.Inconveniences of this mode:Restriction to angles <= Ï in one single command;The perpendicular vector has to be computed.Example:\nAuxPoint = (50,0,0) -> Circle in plane parallel to yz\nplane with radius 50 and rotation around axis\nparallel to x-axis according to the rule of right thumb\n(CoordSystem = MCS)"
        }
      ]
    }
  ]
}