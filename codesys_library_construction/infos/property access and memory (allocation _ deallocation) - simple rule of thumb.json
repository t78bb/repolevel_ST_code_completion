{
  "library": "BACnet2",
  "title": "property access and memory (allocation / deallocation) - simple rule of thumb",
  "url": "https://content.helpme-codesys.com/en/libs/BACnet2/Current/Doc/apirst.html#property-access-and-memory-allocation-deallocation-simple-rule-of-thumb",
  "page_title": "Application Programming Interface",
  "text": "\nBACnet objects\nÂ¶\nBACnet objects are represented as function block instances put in the object tree in conjunction with an CODESYS BACnet2 object device (like âBACnet2 Analog Valueâ).\nBACnet objects provide a set of properties - for details see the BACnet-Standard\nANSI/ASHRAE Standard 135-2020\n.\nNames of CODESYS BACnet2 object function blocks follows the BACnet-Standard except whitespace (â â) is removed, and a prefix BACnet is added.\nExample:\nBACnet-Standard: âAnalog Valueâ (Object Type) - see ANSI/ASHRAE Standard 135-2020 chapter 12.4\nCODESYS BACnet2: function block BACnetAnalogValue\nThose BACnet object function blocks represents the\nproperty access\nfor their properties as either\nvalue access\n(FUNCTION_BLOCK PROPERTY with Get / Set semantic) or\nfunctional access\n(FUNCTION_BLOCK PROPERTY providing specific, functional interface).\nExamples:\nvalue access\n- Command.ProfileLocation := ââ;\nfunctional access\n- Command.ActionText.AddElement(âtextâ);\nThis\nproperty access\nis using data types defined in CmpBACnet2 in most cases, only some aspects of\nproperty access\nuse IEC-61311 standard types for convenience (STRING and WSTRING might be the most prominent examples).\nFurthermore the existance, writeability and eventually persistance of those BACnet properties can be controlled by the application (lets call this\nproperty attributes\nlater on).\nFor a subset of the properties the initial value can be configured using the configurator within the CODESYS engineering tool - this applies to mostly all properties of scalar / simple types, but not to properties of complex types.\nThe\nproperty attributes\ncan be configured for all properties using the configurator within the CODESYS engineering tool - see folder âpropertyAttributesâ.\nFurthermore the property attributes can also be controlled by application code, for more details see\nIBACnetPropertyConfiguration\nand BACnetDefaultImpl.PropertyConfiguration / BACnetDefaultImpl.PropertyConfigurationMostlyAllWritable.\nBACnet types (of BACnet object properties) defined in the BACnet-Standard falls into one of the following categories:\nsimple type - for example see BACnet-Standard: BOOLEAN, Unsigned, REAL, STRING, WSTRING\ncomplex type not containing\nSEQUENCE\nâs (of other elements - for example see BACnet-Standard: BACnetObjectPropertyReference\ncomplex type containing\nSEQUENCE\nâs (of other elements) - for example see BACnet-Standard: BACnetActionList\ndynamic type - see BACnet-Standard: ANY\nSEQUENCE\nis a concept of the BACnet-Standard represented as POINTER TO type in CODESYS BACnet2 resp. CmpBACnet2 types.\nBACnet object properties defined in the BACnet-Standard falls into one of these categories:\nsingle value\nfix size array - see BACnet-Standard:\nBACnetARRAY[?] of\n- example âAnalog Value Object Typeâ - Event_Message_Texts_Config (BACnetARRAY[3] of CharacterString)\ndynamic size array - see BACnet-Standard:\nBACnetARRAY[N] of\n- example âGlobal Group Object Typeâ - Group_Members (BACnetARRAY[N] of BACnetDeviceObjectPropertyReference)\nlist (always dynamic size) - see BACnet-Standard:\nBACnetLIST of\n- example âCalendar Object Typeâ - Date_List (BACnetLIST of BACnetCalendarEntry)\nproperty access and content data memory\nÂ¶\nThe\nproperty access\nis often implemented using the data type CmpBACnet2.IEC_BACNET_PROPERTY_CONTENTS in some way.\nCmpBACnet2.IEC_BACNET_PROPERTY_CONTENTS determines the BACnet type used in the member\ntag\n,\nthe number of elements in the member\nnElements\nand refers to the content data with the member\nbuffer\n(of type CmpBACnet2.IEC_BACNET_BUFFER).\nMemory for CmpBACnet2.IEC_BACNET_BUFFER.pBuffer is either provided by the application or returned by the BACnet API (and needs to be released by the application using\nFreeStackAllocatedMemory\nin this case).\nIn case the BACnet API returns the memory for CmpBACnet2.IEC_BACNET_BUFFER.pBuffer, the whole content data are put in one contiguous content data memory block, even if the content data itself contains POINTERâs,\nso FreeStackAllocatedMemory(IEC_BACNET_PROPERTY_CONTENTS.buffer.pBuffer) is sufficient to release all content data memory.\nIn case the application provides content data memory - for example for write property access - it is wise to avoid dynamically (heap) allocated content data memory,\nbut to work with stack allocated content data memory instead. This approach avoids the hazzle to do complex deep dealloc of application content data memory.\nPlease be aware: in case application provided, dynamically (heap) allocated content data memory is inevitable itâs up to your diligence to do proper deep dealloc of application content data memory to avoid memory leaks.\nBACnetARRAY[] of\nvs.\nBACnetLIST of\nproperties\nÂ¶\nThe BACnet-Standard states:\ncitation:\nThe difference between a âBACnetARRAYâ property and a âBACnetLISTâ property is that the elements of the array can be\nuniquely accessed by an array index while the elements of the âBACnetLISTâ property can only be positionally accessed using\nthe ReadRange service. Moreover, the number of elements in the BACnetARRAY may be ascertained by reading the array\nindex 0, while the number of elements present in a âBACnetLISTâ property can only be determined by reading the entire\nproperty value and performing a count.\nend of citation.\nFor more details see ANSI/ASHRAE Standard 135-2020 chapter 12.1.5 Array and List Properties.\nThe BACnet-Standard enforces this significant difference between BACnetARRAY and BACnetLIST by means of BACnet wire telegram definitions (APDUâs) - so a BACnet client can not do a index based property access for BACnetLIST properties (on the wire directly).\nPlease keep in mind, that\nBACnetARRAY[] of\nelement ordering might be relevant.\nproperty type\nANY\nÂ¶\nThis property type allows to represent property values of any (other) type defined in the BACnet-Standard,\nwhich makes the correct handling a bit more challenging.\nThe\nproperty access\nfor those properties is implemented using\nfunctional access\n(with Get/Set semantic) with the argument type CmpBACnet2.IEC_BACNET_PROPERTY_CONTENTS.\nAs described before CmpBACnet2.IEC_BACNET_PROPERTY_CONTENTS determines the BACnet type used in the member\ntag\n,\nthe number of elements in the member\nnElements\nand refers to the content data with the member\nbuffer\n(of type CmpBACnet2.IEC_BACNET_BUFFER).\nSo it is up to the application code to get this right.\nFortunately the BACnet-Standard is utilizing this concept of ANY only for the âSchedule Object Typeâ properties Present_Value and Schedule_Default,\nwhich limits the hazzle to a very small subset of the API.\napplication programming interface conventions for property access\nÂ¶\nIt had been laid out before that\nproperty access\nis represented as\nvalue access\n(Get / Set) or\nfunctional access\n.\nWithin the aspect of\nproperty access\nthere is a need to spend some thoughts about memory (allocation / deallocation) and memory ownership transfer from CODESYS BACnet2 to the application.\nProperty access is represented as\nvalue access\nfor the following subset of all BACnet properties:\nsingle value of simple type or complex type not containing SEQUENCEâs\nfix size array of simple type or complex type not containing SEQUENCEâs\nwhereas of the name of the\nvalue access\nFUNCTION_BLOCK PROPERTY follows the BACnet-Standard except underscore (â_â) is removed.\nExample:\nBACnet-Standard: âAnalog Value Object Typeâ property Out_Of_Service (type BOOLEAN)\nCODESYS BACnet: function block BACnetAnalogValue PROPERTY OutOfService (type IEC-61311 BOOL)\nAll\nproperty access\nof the types listed above provides pure value semantics and such no memory ownership transfer is involved.\nPlease note: for fix size array properties the\nvalue access\nget / set the whole array (by value).\nAll other\nproperty access\nexistent at the CODESYS BACnet2 API is represented as\nfunctional access\nfor:\nsingle value of complex type containing SEQUENCEâs\nfix size array properties of complex type containing SEQUENCEâs\ndynamic size array properties\nlist properties\nwhereas of the name of the\nfunctional access\nFUNCTION_BLOCK PROPERTY follows the BACnet-Standard except underscore (â_â) is removed.\nFor\nfunctional access\n:\nthe related FUNCTION_BLOCK PROPERTY provides a specific, functional interface containing appropriate METHODs\nmemory ownership transfer is involved at some points (METHODs)\nFor BACnet single value properties of complex type containing SEQUENCEâs the\nproperty access\nis represented as\nfunctional access\nwith the METHODs listed below:\nGetContent() - get the property value, passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nSetContent() - set the property value\nExample:\nBACnet-Standard: âAnalog Value Object Typeâ property Priority_Array(BACnetPriorityArray)\nCODESYS BACnet: function block BACnetAnalogValue TODO Interface\n- PriorityArray.GetContent()\n- PriorityArray.SetContent()\nFor BACnet fix size array properties of complex type containing SEQUENCEâs the\nproperty access\nis represented as\nfunctional access\nwith the METHODSs listed below:\nGetContent() - get the whole array, passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nSetContent() - set the whole array\nGetCount() - get the number of elements in the array\nGetElement() - get array element at index (0 .. number of elements-1), passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nUpdateElement() - update array element at index (0 .. number of elements-1)\nExample:\nBACnet-Standard: âSchedule Object Typeâ property Weekly_Schedule(BACnetARRAY[7] of BACnetDailySchedule)\nCODESYS BACnet: function block BACnetSchedule PROPERTY WeeklySchedule of type\nIBACnetARRAYF_of_BACnetDailySchedule\n- WeeklySchedule.GetContent()\n- WeeklySchedule.SetContent()\n- WeeklySchedule.GetCount()\n- WeeklySchedule.GetElement()\n- WeeklySchedule.UpdateElement()\nFor BACnet dynamic size array properties the\nproperty access\nis represented as\nfunctional access\nwith the METHODs listed below:\nGetContent() - get the whole array, passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nSetContent() - set the whole array\nGetCount() - get the number of elements in the array\nGetElement() - get array element at index (0 .. number of elements-1), if element type is complex type containing SEQUENCEâs passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nUpdateElement() - update array element at index (0 .. number of elements-1)\nInsertElement() - insert array element at index (0 .. number of elements-1)\nAddElement() - add element at the end off array\nRemoveElement() - remove array element at index (0 .. number of elements-1)\nExample:\nBACnet-Standard: âGlobal Group Object Typeâ property Group_Members (BACnetARRAY[N] of BACnetDeviceObjectPropertyReference)\nCODESYS BACnet: function block BACnetGlobalGroup PROPERTY GroupMembers of type\nIBACnetARRAYN_of_BACnetDeviceObjectPropertyReference\n- GroupMembers.GetContent()\n- GroupMembers.SetContent()\n- GroupMembers.GetCount()\n- GroupMembers.GetElement()\n- GroupMembers.UpdateElement()\n- GroupMembers.InsertElement()\n- GroupMembers.AddElement()\n- GroupMembers.RemoveElement()\nWhy is the GetElement() passing memory ownership to the caller in some cases?\nHaving a value semantic requires the caller to know the needed memory size to provide.\nFor complex type containing SEQUENCEâs is not possible for the caller to determine the memory size prior the get the element value - sorry for this inconvenience.\nFor BACnet list properties properties the\nproperty access\nis represented as\nfunctional access\nwith the METHODs listed below:\nGetContent() - get the whole list, passing memory ownership to the caller via a POINTER TO, requiring\nFreeStackAllocatedMemory\nafter processing\nSetContent() - set the whole list\nGetCount() - get the number of elements in the list\nUpdateElement() - update list element at index (0 .. number of elements-1)\nInsertElement() - insert list element at index (0 .. number of elements-1)\nAddElement() - add element at the end off list (0 .. number of elements-1)\nRemoveElement() - remove list element at index (0 .. number of elements-1)\nPlease note that the number of elements in the list is also provided from Get(), so avoid the expensive call to GetCount() wherever possible.\nExample:\nBACnet-Standard: âCalendar Object Typeâ property Date_List(BACnetLIST of BACnetCalendarEntry)\nCODESYS BACnet: function block BACnetCalendar PROPERTY DateList of type\nIBACnetLIST_of_BACnetCalendarEntry\n- DateList.GetContent()\n- DateList.SetContent()\n- DateList.GetCount()\n- DateList.UpdateElement()\n- DateList.InsertElement()\n- DateList.AddElement()\n- DateList.RemoveElement()\nexceptions from\nproperty access\nnaming conventions\nÂ¶\nIn some exceptional cases naming doesnât clamp to the BACnet-Standard too much, because:\n- part of the BACnet property name duplicates the container type (array vs. list)\nâGroup Object Typeâ property List_Of_Group_Members\nâSchedule Object Typeâ property List_Of_Object_Property_References\nâTimer Object Typeâ property List_Of_Object_Property_References\nFor those properties the API skips the prefix â\nList_Of_\nâ within the names of the related\nfunctional access\nproperties.\nBACnet property name is wrong regarding the container type (array vs. list)\nâChannel Object Typeâ property List_Of_Object_Property_References (of type BACnetARRAY[N] of BACnetDeviceObjectPropertyReference)\nFor this property the API skips the prefix â\nList_Of_\nâ within the names of the related\nfunctional access\nPROPERTY.\nBACnet property name clashes with a CODESYS IEC-61131 keyword\nFor those properties the API adds a postfix âPropertyâ to the names of the related\nfunctional access\nproperties.\nexample âCommand Object Typeâ property Action is named ActionProperty\nproperty access and memory (allocation / deallocation) - simple rule of thumb\nÂ¶\nThe CODESYS BACnet2 API has been designed to make it easy to get memory allocation / deallocation at property access right.\nPlease note - BACnet fix size array properties of complex type containing SEQUENCEâs doesnt provide\nproperty access\nrepresented as\nvalue access\nfor good reason.\nComplex type containing SEQUENCEâs require the memory for the SEQUENCE (referenced by the POINTER TO member of the datatype) been allocated by the BACstack reading those properties,\nthus requiring the caller the to release the memory calling\nFreeStackAllocatedMemory\nafter processing.\nSimiliar to this BACnet list properties doesnt provide property element read access for good reason.\nOf ourse the need to call\nFreeStackAllocatedMemory\nis documented wherever needed, but itâs helpful to have simple rules as well.\nSo the simple rule of thumb is:\n1.) wherever there is a memory ownership transfer from CODESYS BACnet2 to the application there is a need to call\nFreeStackAllocatedMemory\nafter usage.\n2.) if property access is represented as\nvalue access\nthere is always value semantic so no memory ownership transfer\n3.) if property access is represented as\nfunctional access\n3.1.) if property is of complex type containing SEQUENCEâs\nGetContent() and GetElement()\ndo memory ownership transfer\n3.2.) if property is of simple type or complex type not containing SEQUENCEâs\nGetContent()\ndoes memory ownership transfer\nall other methods\ndo have value semantic, so there is no memory ownership transfer\nThe differantiation between 2.1.) and 2.2) is a bit more subtle.\nGetContent()\ndoes always memory ownership transfer but\nGetElement()\nmight or might not so read documentation of GetElement() carefully.\nIn case GetElement() write the element value onto a variable provided by the caller via VAR_IN_OUT, there is value semantic and so no memory ownership transfer.\nIn case GetElement() passes the element value to the caller by the means of POINTER TO there is memory ownership transfer.\n4.)\nyou\nneed to take care for\nyour own memory\nyou pass on to property\nwrite access\nSTRING / WSTRING exceptions from\nproperty access\ntype consistency\nÂ¶\nIt had been laid out before, that\nproperty access\nis using data types defined in CmpBACnet2 in most cases, only some aspects of\nproperty access\nuse IEC-61311 standard types for convenience.\nThis comes with an exception in consistency regarding STRING / WSTRING vs. CmpBACnet.IEC_BACNET_STRING.\nThe BACstack and so CmpBACnet2 is using CmpBACnet.IEC_BACNET_STRING to represent the BACnet type called CharacterString within the BACnet-Standard.\nCmpBACnet.IEC_BACNET_STRING comes with a POINTER TO string buffer and features for codepage, which makes the handling a bit mor complex than STRING / WSTRING.\nProperty access\nwithin CODESYS BACnet up to version 1.7.*.* was utilizing STRING / WSTRING for single value properties for convenience.\nThis avoids the hazzle for the user to deal with encoding/decoding, codepage-conversion and memory ownership transfer for CmpBACnet.IEC_BACNET_STRING.data on those pieces of the API,\nbut pays the price of in-place conversion at call.\nThe shortcoming of this approach was: CharacterString nested into complex types had not been treated this way,\nbecause it would require complete transformation of all complex types containg CharacterString into\nBACnet.library\ntypes plus the whole conversion functionality - which is expensive in many ways.\nThis inconsistency brought up with CODESYS BACnet up to version 1.7.*.* had been kept in the within CODESYS BACnet2 API for two reason:\ncompatibility\nsome convenience for single value properties of type CharacterString\ntop\nCODESYS Group | We\nsoftware\nAutomation.\nto software\n['sɒftwɛər]\ntransitive verb\n__softwared/softwaring\n: to develop software\n// to software automation: to develop software for automation purposes\nThe CODESYS Group is the manufacturer of CODESYS, the leading hardware-independent\n                                    IEC 61131-3 automation software for developing and engineering controller\n                                    applications.\nCODESYS® is a registered trademark.\nCODESYS GmbH\nA member of the CODESYS Group\nMemminger Straße 151, 87439 Kempten\nGermany\nTel.:\n+49-831-54031-0\ninfo@codesys.com\nLegal Notice\nPrivacy Policy\nLinkedIn\nYoutube\nRSS\nDownloads\nLogin\nCODESYS Store\n© 2022 CODESYS GmbH\n| A member of the CODESYS Group",
  "tables": []
}